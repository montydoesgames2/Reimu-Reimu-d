// -- Gohei Stick -- \\

// How it works:

// Imagine Pyra's Blazing End in SSBU. Yeah.

//# address-hook(0x0fa19c) end(0x0fa1ee)
function void GoheiStick.Init()
{
	objA0.mapping_offset = 0x01a464
	objA0.render_flags = render_flag.WORLD
	objA0.sprite_priority = 0x80
	objA0.box_size.x = 0x40
	objA0.box_size.y = 0x40
	objA0.sprite_attributes = (sprite_attribute.PRIORITY | (Char.Player1.targetInVRAM >> 5))
	objA0.position.x.u16 = u16[0xffffb010]
	objA0.position.y.u16 = u16[0xffffb014]
	objA0.velocity.x = 0
	objA0.velocity.y = 0
	objA0.base_state = 0x02

	objA0.update_address = 0x0fa1f4
	GoheiStick.Update()
}


//# address-hook(0x0fa1f4) end(0x0fa226)
function void GoheiStick.Update()
{
	if (objA0.base_state != 0x02)
		GoheiReturn()
	else
	{
		objA0.position.x.u16 = u16[0xffffb010]
		objA0.position.y.u16 = u16[0xffffb014]

		bool launchUp = (!(global.inv_gravity) && (control.player1.state & CONTROL_UP)) || ((global.inv_gravity) && (control.player1.state & CONTROL_DOWN))
		if !(control.player1.state & CONTROL_ABC) || (launchUp)
		{
			objA0.base_state = (launchUp) ? 0x06 : 0x04
			objA0.countdown_value = (launchUp) ? 90 : 15
		}
		else if (u8[0xffffb02f] == 0)
			UnloadObject()
	}

	u32 backupA1 = A1
	ReimuObjects.DoCollisionShit()
	A1 = backupA1
	GoheiStickUpdateRingCollection()

	// Some rendering shenanigans we don't really need another function for

	if (objA0.base_state == 0x02) // Once you release the stick it shouldn't need to check this
	{
		if (u8[0xffffb004] & render_flag.FLIP_X)
			objA0.render_flags |= render_flag.FLIP_X
		else
			objA0.render_flags &= ~render_flag.FLIP_X
	}

	// Still a chance it's on screen when gravity flips so this is always checked
	objA0.render_flags &= ~render_flag.FLIP_Y
	if (global.inv_gravity)
	{
		objA0.render_flags |= render_flag.FLIP_Y
	}

	if objA0.animation.sprite == 0
		playSound(SFX_INSTASHIELD)

	--objA0.animation.timer
	if (s8(objA0.animation.timer) < 0)
	{
		objA0.animation.timer = 1
		++objA0.animation.sprite
		objA0.animation.sprite %= 8
	}

	DrawObject()
}

function void ReimuObjects.DoCollisionShit() // WORK, DAMMIT
{
	u16 numObjects = global.dynamic_objects.size + 4		// Actually it's twice the number of dynamic objects
	A4 = addressof(global.dynamic_objects.size) + 2		// Resulting address: 0xffffe382
	while (numObjects != 0)
	{
		// Get address of dynamic object
		A1 = 0xffff0000 + u16[A4]
		A4 += 2

		// Offset into a list of hitbox sizes (the list looks a bit random)
		u16 offset = objA1.collision_attributes
		if (offset != 0)
		{
			// Targets:
			//  - 0x04 x 0x04  -> (offset & collision_attributes.size) = collision.size.4x4
			//  - 0x14 x 0x14  -> (offset & collision_attributes.size) = collision.size.20x20
			//  - 0x0c x 0x14  -> (offset & collision_attributes.size) = collision.size.12x20
			//  - 0x14 x 0x0c  -> (offset & collision_attributes.size) = collision.size.20x12
			//  - 0x04 x 0x10  -> (offset & collision_attributes.size) = collision.size.4x16
			//  - 0x0c x 0x12  -> (offset & collision_attributes.size) = collision.size.12x18
			//  - 0x10 x 0x10  -> (offset & collision_attributes.size) = collision.size.16x16
			//  - 0x06 x 0x06  -> (offset & collision_attributes.size) = collision.size.6x6
			//  - 0x18 x 0x0c  -> (offset & collision_attributes.size) = collision.size.24x12
			//  - 0x0c x 0x10  -> (offset & collision_attributes.size) = collision.size.12x16
			//  - 0x10 x 0x08  -> (offset & collision_attributes.size) = collision.size.16x8
			//  - 0x08 x 0x08  -> (offset & collision_attributes.size) = collision.size.8x8
			//  - 0x14 x 0x10  -> (offset & collision_attributes.size) = collision.size.20x16
			//  - 0x14 x 0x08  -> (offset & collision_attributes.size) = collision.size.20x8
			//  - 0x0e x 0x0e  -> (offset & collision_attributes.size) = collision.size.14x14
			//  - 0x18 x 0x18  -> (offset & collision_attributes.size) = collision.size.24x24
			//  - 0x28 x 0x10  -> (offset & collision_attributes.size) = collision.size.40x16
			//  - 0x10 x 0x18  -> (offset & collision_attributes.size) = collision.size.16x24
			//  - 0x08 x 0x10  -> (offset & collision_attributes.size) = collision.size.8x16
			//  - 0x20 x 0x70  -> (offset & collision_attributes.size) = collision.size.32x112
			//  - 0x40 x 0x20  -> (offset & collision_attributes.size) = collision.size.64x32
			//  - 0x80 x 0x20  -> (offset & collision_attributes.size) = collision.size.128x32
			//  - 0x20 x 0x20  -> (offset & collision_attributes.size) = collision.size.32x32
			//  - 0x08 x 0x08  -> (offset & collision_attributes.size) = collision.size.8x8_2
			//  - 0x04 x 0x04  -> (offset & collision_attributes.size) = collision.size.4x4_2
			//  - 0x20 x 0x08  -> (offset & collision_attributes.size) = collision.size.32x8
			//  - 0x0c x 0x0c  -> (offset & collision_attributes.size) = collision.size.12x12
			//  - 0x08 x 0x04  -> (offset & collision_attributes.size) = collision.size.8x4
			//  - 0x18 x 0x04  -> (offset & collision_attributes.size) = collision.size.24x4
			//  - 0x28 x 0x04  -> (offset & collision_attributes.size) = collision.size.40x4
			//  - 0x04 x 0x08  -> (offset & collision_attributes.size) = collision.size.4x8
			//  - 0x04 x 0x18  -> (offset & collision_attributes.size) = collision.size.4x24
			//  - 0x04 x 0x28  -> (offset & collision_attributes.size) = collision.size.4x40
			//  - 0x18 x 0x18  -> (offset & collision_attributes.size) = collision.size.24x24_2
			//  - 0x18 x 0x18  -> (offset & collision_attributes.size) = collision.size.24x24_3
			//  - 0x0c x 0x18  -> (offset & collision_attributes.size) = collision.size.12x24
			//  - 0x48 x 0x08  -> (offset & collision_attributes.size) = collision.size.72x8
			//  - 0x18 x 0x28  -> (offset & collision_attributes.size) = collision.size.24x40
			//  - 0x10 x 0x04  -> (offset & collision_attributes.size) = collision.size.16x4
			//  - 0x20 x 0x02  -> (offset & collision_attributes.size) = collision.size.32x2
			//  - 0x10 x 0x1c  -> (offset & collision_attributes.size) = collision.size.16x28
			//  - 0x0c x 0x24  -> (offset & collision_attributes.size) = collision.size.12x36
			//  - 0x10 x 0x02  -> (offset & collision_attributes.size) = collision.size.16x2
			//  - 0x04 x 0x40  -> (offset & collision_attributes.size) = collision.size.4x64
			//  - 0x18 x 0x40  -> (offset & collision_attributes.size) = collision.size.24x64
			//  - 0x20 x 0x10  -> (offset & collision_attributes.size) = collision.size.32x16
			//  - 0x1c x 0x14  -> (offset & collision_attributes.size) = collision.size.28x20
			//  - 0x10 x 0x02  -> (offset & collision_attributes.size) = collision.size.16x2_2
			//  - 0x10 x 0x01  -> (offset & collision_attributes.size) = collision.size.16x1
			//  - 0x02 x 0x08  -> (offset & collision_attributes.size) = collision.size.2x8
			//  - 0x10 x 0x40  -> (offset & collision_attributes.size) = collision.size.16x64
			//  - 0x0c x 0x04  -> (offset & collision_attributes.size) = collision.size.12x4
			//  - 0x08 x 0x0c  -> (offset & collision_attributes.size) = collision.size.8x12
			//  - 0x28 x 0x20  -> (offset & collision_attributes.size) = collision.size.40x32
			//  - 0x40 x 0x02  -> (offset & collision_attributes.size) = collision.size.64x2
			//  - 0x60 x 0x02  -> (offset & collision_attributes.size) = collision.size.96x2
			//  - 0x28 x 0x28  -> (offset & collision_attributes.size) = collision.size.40x40
			A2 = 0x00ff62 + (offset & collision_attributes.size) * 2
			s16 hitbox.x = u8[A2]
			s16 hitbox.y = u8[A2+1]

			u16 px = objA1.position.x.u16 - hitbox.x
			u16 py = objA1.position.y.u16 - hitbox.y
			u16 sx = hitbox.x * 2
			u16 sy = hitbox.y * 2

		#if STANDALONE
			if (DEBUG_DYNAMIC_COLLISIONS)
			{
				if ((offset & collision_attributes.flags) == collision.flag.ITEM)
					debugDrawRect(px, py, sx, sy, 0x8000ff00)
				else if ((offset & collision_attributes.flags) == collision.flag.SPECIAL)
					debugDrawRect(px, py, sx, sy, 0x80ff0000)
				else if ((offset & collision_attributes.flags) == collision.flag.THREAT)
					debugDrawRect(px, py, sx, sy, 0x800000ff)
				else
					debugDrawRect(px, py, sx, sy, 0x80ff00ff)
			}
		#endif

			if (checkBoxOverlap(objA0.position.x.u16 - 0x20, objA0.position.y.u16 - 0x20, 0x40, 0x40, px, py, sx, sy))
			{
				// Collision found
				ReimuObjects.OnCollisionWithDynamicObject()
				return
			}
		}

		numObjects -= 2
	}
}

function void ReimuObjects.OnCollisionWithDynamicObject()
{
	// Example values for objA1.collision_attributes:
	//  - 0x06, 0x0b, 0x17, 0x1a = Different types of enemies
	//  - 0x0f		 = Boss enemy
	//  - 0x18		 = Extended arm of DEZ Chainspike
	//  - 0x23		 = AIZ Bloominator
	//  - 0x46		 = Monitor
	//  - 0x47		 = Dynamic ring
	//  - 0x87		 = Extended arm of SOZ Skorp
	//  - 0x8b, 0x9c = Flames, damaging parts of enemies
	//  - 0x8f		 = Wrecking ball
	//  - 0x98, 0x9b = Projectile
	//  - 0xd8		 = Thrown mushroom, stars over starpost

	D1.u8 = (objA1.collision_attributes & collision_attributes.flags)
	if (D1.u8 == 0)
	{
		// Collision is an enemy, i.e. is harmful, but can be attacked
		{
			if (u8[A1 + 0x29] != 0)
			{
				u8[A1 + 0x1c] = A0.u8
				u8[A1 + 0x25] = u8[A1 + 0x28]
				u8[A1 + 0x28] = 0
				--u8[A1 + 0x29]
				if (u8[A1 + 0x29] == 0)
				{
					u8[A1 + 0x2a] |= 0x80
				}
			}
			else
			{
				if (u8[A1 + 0x2a] & 0x04)
				{
					A2 = 0xffff0000 + u16[A1 + 0x3c]
					u8[A2] &= ~(1 << u8[A1 + 0x3b])
				}
	
				u8[A1 + 0x2a] |= 0x80
	
				// Grant bonus points
				Enemy.addScore(A1, 0x010216)
	
				objA1.update_address = addressof(SmallExplosion.BaseUpdate)
				u8[A1 + 0x05] = 0
				if (char.velocity.y < 0)
				{
					char.velocity.y += 0x100
				}
				else if (char.position.y.u16 >= objA1.position.y.u16)
				{
					char.velocity.y -= 0x100
				}
				else
				{
					char.velocity.y = -char.velocity.y
				}
			}
		}
	}
	else if (D1.u8 == collision.flag.ITEM)
	{
		D0.u8 = (objA1.collision_attributes & collision_attributes.size)
		if (D0.u8 != collision.size.16x16)
		{
			// Collect ring, but only after 30 invulnerability frames
			//  -> Remember that the "char.invuln.countdown" timer starts at 120
			u8[A1 + 0x05] = 0x04
		}
		else
		{
			objA1.base_state = 0x04		// Set monitor state to broken
			objA1.monitor.character_address = 0xffffb000		// RAM address of character
		}
	}
	else  // D1.u8 == collision.flag.SPECIAL
	{
		// Other interactable object
		fn0103ba()
	}
}

function void GoheiReturn()
{
	if (objA0.base_state == 0x04)
	{
		u8[0xffffb02f] = 2
		objA0.position.x.u16 += (objA0.render_flags & render_flag.FLIP_X) ? -8 : 8

		--objA0.countdown_value
		if (objA0.countdown_value < 0)
		{
			objA0.base_state = 0x06
			objA0.countdown_value = 60
		}
	}
	else if (objA0.base_state == 0x06)
	{
		--objA0.countdown_value
		if (objA0.countdown_value < 0)
		{
			objA0.base_state = 0x08
			objA0.countdown_value = 300
		}
	}
	else
	{
		D2.u16 = u16[0xffffb000 + 0x10]
		D3.u16 = u16[0xffffb000 + 0x14]
		fn01a37a()

		s16 xfromplayer = objA0.position.x.u16 - s16[0xffffb010]
		s16 yfromplayer = objA0.position.y.u16 - s16[0xffffb014]
		bool reachedPlayer = (xfromplayer <= 0x0c && xfromplayer >= -0x0c) && (yfromplayer <= 0x0c && yfromplayer >= -0x0c)

		--objA0.countdown_value
		if (objA0.render_flags & render_flag.VISIBLE)
		{
			objA0.countdown_value = 300
		}

		if (reachedPlayer) || (objA0.countdown_value < 0) // Unload if close enough to the player, or if too far away
			UnloadObject()
	}

	u8[A1 + 0x2d] = 0
	u8[A0 + 0x30] = 0
	u8[A0 + 0x32] = 0x78

}

function void GoheiStickUpdateRingCollection()
{
	// Shortly after getting hit, you can't collect rings
	if (u8[0xffffb034] >= 90)
		return

	u16 box.pos.x
	u16 box.pos.y
	u16 box.size.x
	u16 box.size.y

	box.pos.x = objA0.position.x.u16 - 0x20
	box.pos.y = objA0.position.y.u16 - 0x20
	box.size.x = objA0.box_size.x
	box.size.y = objA0.box_size.y

#if STANDALONE
	if (DEBUG_DYNAMIC_COLLISIONS >= 3)
		debugDrawRect(box.pos.x, box.pos.y, box.size.x, box.size.y, 0x80ffff00)
#endif

	// Cycle through list of all rings with x-position in screen area
	A1 = rings.around.first
	A2 = rings.around.last
	A4 = 0xffff0000 + rings.around.first.state

	while (A1 != A2)
	{
		// Check if already collected
		if (u16[A4] == 0)
		{
			u16 ring.x = u16[A1 + 0]
			u16 ring.y = u16[A1 + 2]

			s16 ring.offset = 6
			s16 ring.size = 12

			u16 px = ring.x - ring.offset
			u16 py = ring.y - ring.offset

		#if STANDALONE
			// Consider vertical level wrap
			if (level.vertical_wrap == 0xff00)
			{
				s16 dy = py - box.pos.y
				if (dy < -s16(level.height.bitmask)/2)
				{
					py += (level.height.bitmask + 1)
				}
				else if (dy > level.height.bitmask/2)
				{
					py -= (level.height.bitmask + 1)
				}
			}
		#endif

		#if STANDALONE
			if (DEBUG_DYNAMIC_COLLISIONS >= 3)
				debugDrawRect(px, py, ring.size, ring.size, 0x80ffff00)
		#endif

			if (checkBoxOverlap(box.pos.x, box.pos.y, box.size.x, box.size.y, px, py, ring.size, ring.size))
			{
				if (char.bonus_effect & char.bonus.SHIELD_LIGHTNING)
				{
					if (makeDynamicRing())
						return
				}

				// Start ring animation, ring counts as collected now
				u16[A4] = 0x0604

				// Collect this ring
				CollectLevelRing()

				// This seems to be some kind of table of the currently animated rings
				A3 = 0xffffef82
				while (u16[A3] != 0)
				{
					A3 += 2
				}
				u16[A3] = A4.u16

				++u16[0xffffef80]
			}
		}

		A1 += 4
		A4 += 2
	}
}

function bool Standalone.onWriteToSpriteTable(s16 px, s16 py, u16 renderQueue)
{
	if (objA0.update_address == 0x0fa1f4)
	{
		if (global.characters == CHARACTER_REIMU || global.characters == CHARACTER_REIMU_TAILS || global.characters == CHARACTER_REIMU || global.characters == CHARACTER_REIMU_TAILS) // Reimu
		{
			Renderer.drawCustomSprite(stringformat("Reimu_Gohei_%d", objA0.animation.sprite), px, py, 0x00, objA0.render_flags + SPRITE_FLAG_PRIO, renderQueue)
			return true
		}
	}

	return base.Standalone.onWriteToSpriteTable(px, py, renderQueue)
}

function void ReimuPressedJumpInMidAir()
{
	// Remove control lock
	char.flags &= ~char.flag.CONTROL_LOCK

	s16 backupD7 = D7.s16
	u32 backupA1 = A1
	D7.s16 = 0x6d
	A1 = 0xffffb000
	while (D7.s16 >= 0) && (super.active != 0xff)
	{
		if (u32[A1] == 0x0fa1f4)
			return
		// Go on to next object
		A1 += 0x4a
		--D7.s16
	}
	D7.s16 = backupD7
	A1 = backupA1

	char.double_jump_state = 1	// Always set this flag; needed for Gohei Stick

	if (allocDynamicObjectStd())
	{
		// Gohei
		objA1.update_address = 0x0fa19c
		objA1.base_state = 0x02
	}
}

function void Character.updateJumpMoves()
{
	if (global.characters != CHARACTER_REIMU && global.characters != CHARACTER_REIMU_TAILS) || (char.character != CHARACTER_SONIC)
	{
		base.Character.updateJumpMoves()
		return
	}

	u8 input_state     = (char.character == CHARACTER_TAILS) ? control.tails.state   : control.player1.state
	u8 input_pressed   = (char.character == CHARACTER_TAILS) ? control.tails.pressed : control.player1.pressed
	bool isSuperActive = (char.character == CHARACTER_TAILS) ? super.active.tails    : super.active

	if (char.jumping)
	{
		// Limit velocity.y
		s16 max_vy = (char.flags & char.flag.UNDERWATER) ? -0x200 : -0x400
		if (char.velocity.y < max_vy) && (char.double_jump_state != 2)
		{
			// Limit vertical velocity while not pressing any jump button
			//  -> This is important to support low jumps by just tapping the button briefly
			if ((input_state & CONTROL_ABC) == 0)
			{
				char.velocity.y = max_vy
			}
		}
		else
		{
			bool launchUp = (!(global.inv_gravity) && (input_state & CONTROL_UP)) || ((global.inv_gravity) && (input_state & CONTROL_DOWN))
			if (char.double_jump_state == 0)
			{
				#if STANDALONE
					if (Input.buttonPressed(BUTTON_Y))
					{
						if (!isSuperActive && char.invuln.countdown == 0)	// Check invulnerability to prevent spamming of super activate + cancel
						{
							if (Character.performSuperTransformation())
								return
						}
					}
				#endif

				// Check if pressed jump again in mid-air
				if (input_pressed & CONTROL_ABC)
				{
				#if STANDALONE
					// Check for other things to do instead of the usual reaction to jump button pressed
					if (onCharacterPressedJumpInMidAir(input_state, input_pressed))
				#endif
					{
						ReimuPressedJumpInMidAir()
					}
				}
			}
			else if (char.double_jump_state == 1) && (launchUp)
			{
				char.velocity.y = -0x800
				char.double_jump_state = 2
				char.state = char.state.STRAIGHTJUMP
			}
		}
	}
	else
	{
		if (char.spindash == 0)
		{
			char.velocity.y = max(char.velocity.y, -0x0fc0)
		}
	}
}

//# address-hook(0x012232) end(0x0122b8)
function void SonicLandingBubbleBounce()
{
	if (global.characters == CHARACTER_REIMU || global.characters == CHARACTER_REIMU_TAILS || global.characters == CHARACTER_REIMU || global.characters == CHARACTER_REIMU_TAILS)
		return
base.SonicLandingBubbleBounce()
}

function bool Character.updateSuperPeelout()
{
	if (global.characters == CHARACTER_REIMU || global.characters == CHARACTER_REIMU_TAILS || global.characters == CHARACTER_REIMU || global.characters == CHARACTER_REIMU_TAILS)
		return false
return base.Character.updateSuperPeelout()
}

//# address-hook(0x00fe8e) end(0x00ff04)
function void Character.CheckCollisionsWithDynamicObjects()
{
	if (global.characters != CHARACTER_REIMU && global.characters != CHARACTER_REIMU_TAILS)
	{
		base.Character.CheckCollisionsWithDynamicObjects()
		return
	}

	SonicUpdateRingCollection()
	UpdateShieldDeflecting()

	bool hasInstaShield = false
#if STANDALONE
	if (Game.getSetting(SETTING_INSTA_SHIELD))
#endif
	{
		if (char.character == CHARACTER_SONIC && (char.bonus_effect & (char.bonus.ALL_SHIELDS | char.bonus.INVINCIBLE)) == 0)
		{
			hasInstaShield = (char.double_jump_state == 1)
		}
	}

	if (hasInstaShield)
	{
		// Insta-shield makes Sonic briefly invincible and increases his hitbox
		u8 oldBonusEffect = char.bonus_effect
		char.bonus_effect |= char.bonus.INVINCIBLE
	#if STANDALONE
		// Also make insta-shield bounce off projectiles
		char.bonus_effect |= char.bonus.ANY_SHIELD
	#endif

		// Larger hitbox
		D2.u16 = char.position.x.u16 - 0x20
		D3.u16 = char.position.y.u16 - 0x20
		D4.u16 = 0x40
		D5.u16 = 0x40
		Character.CheckCollisionsWithDynamicObjects_partial()

		char.bonus_effect = oldBonusEffect
	}
	else
	{
		D5 = char.hitbox_extends.y - 3
		D2 = char.position.x.u16 - 8
		D3 = char.position.y.u16 - D5.u16
		D4 = 16
		D5 *= 2
		Character.CheckCollisionsWithDynamicObjects_partial()
	}
}