
/*
	CUSTOM ANIMATIONS
	MISC chars use a seperate UpdateAnimation() function to allow better control over which character gets updated and when. this is especially helpful for 2nd player MISC chars.
*/

function void MISC.UpdateAnimation(u8 character)
{
	if character != CHARACTER_REIMU && character != CHARACTER_REIMU_TAILS
	{
		base.MISC.UpdateAnimation(character)
		return
	}
	
	bool IsPlayer1 = (A0 == 0xffffb000) //a check for if the animations are updating for player 1 or not. this can be used to make certain animations only play for player 1.
	
	//BY DEFAULT, this uses the contents of UpdateSonicAnimation(), however if you want the character to use tails/knuckles animation logic, use the contents of those instead.
	//Important to note, unless you have a good reason to use different animation logic than your character's base, you should just use the contents of the character base's update function.
	
	if (char.state != char.state.former)
	{
		char.state.former = char.state
		char.animation.frame = 0
		char.animation.timer = 0
		char.flags &= ~char.flag.PUSHING
	}

	//Don't use this, by default always use base sonic's animation logic.
	/*
	#if STANDALONE
		A1 = (super.active && char.state <= char.state.TRANSFORMING) ? 0x012c3a : 0x012aa6		// Fixed Super Sonic missing some animation states
	#else
		A1 = (super.active) ? 0x012c3a : 0x012aa6
	#endif
	*/

	//Base sonic animation logic.
	A1 = 0x012aa6
	A1 = tableLookupAddress(A1, char.state * 2)
	D0.u8 = u8[A1]

	// D0.u8 is either:
	//  - 0xff when running
	//  - 0xfe when rolling (on ground or in air)
	//  - between 0x00 and 0x7f in other cases (like standing, balancing, spring-jumping, getting hurt, etc.)

	if (D0.u8 < 0x80)
	{
		updateSonicAnimationStanding()
	}
	else if (D0.u8 == 0xff)
	{
		updateSonicAnimationRunning()
	}
	else // if (D0.u8 == 0xfe)
	{
		updateSonicAnimationRolling()
	}
}

//These next three functions correspond to the character base you're using. ONLY keep the ones you're using for your character.

//Change to MISC update function
//# address-hook(0x012600) end(0x01286c)
//# translated(0x012a2a) end(0x012a6e)
function void UpdateSonicAnimation()
{
	if char.state == 0x31 || char.state == 0x36 //Spring twirl & Falling sprites compat
	{
		base.UpdateSonicAnimation()
		return
	}

	if MISC.player > 3
		MISC.UpdateAnimation(MISC.player)
	else
		base.UpdateSonicAnimation()
}

//Change to MISC update function
//# address-hook(0x015868)
function void UpdateTailsAnimation_inner()
{
	if char.state == 0x31 || char.state == 0x36 //Spring twirl & Falling sprites compat
	{
		base.UpdateTailsAnimation_inner()
		return
	}

	if MISC.player > 3
		MISC.UpdateAnimation(MISC.player)
	else
		base.UpdateTailsAnimation_inner()
}

//Change to MISC update function
//# address-hook(0x017d30) end(0x017ef0)
function void UpdateKnucklesAnimation()
{
	if char.state == 0x31 || char.state == 0x36 //Spring twirl & Falling sprites compat
	{
		base.UpdateKnucklesAnimation()
		return
	}

	if MISC.player > 3
		MISC.UpdateAnimation(MISC.player)
	else
		base.UpdateKnucklesAnimation()
}

/*
	BASE CHARACTER RENDERING
	none of this shit actually NEEDS to be edited technically, just use the helper function. but it's here for more specific changes if you'd like.
*/

function bool Standalone.onWriteToSpriteTable(s16 px, s16 py, u16 renderQueue)
{
	bool isPlayer = A0 == 0xffffb000 || A0 == 0xffffb04a
	bool isTailObject = (A0 == tailstails.p1 && u16[tailstails.p1 + 0x30] == 0xb000) || (A0 == tailstails.p2 && u16[tailstails.p2 + 0x30] == 0xb04a)
	#if TAGTEAM_ACTIVE
		// this isn't in by default just so objects that take up those slots don't get confused for players
		isPlayer |= (A0 == 0xffffc2ca || A0 == 0xffffc314) && objA0.update_address == addressof(Character.BaseUpdate.TagTeamPlayer)
		isTailObject |= (A0 == tailstails.p3 && u16[tailstails.p3 + 0x30] == 0xc2ca) || (A0 == tailstails.p4 && u16[tailstails.p4 + 0x30] == 0xc314)
	#endif
    if ((isPlayer || isTailObject) && (MISC.player == CHARACTER_REIMU || MISC.player == CHARACTER_REIMU_TAILS))
	{
		if (debug_mode.state && debug_mode.state != 2 && A0 == 0xffffb000) // debug mode "placement" state
			return false
		return MISC.drawCHARACTER_REIMU(char.character, (isTailObject ? 2 : (A0 == 0xffffb000) ? 0 : 1), px, py, false)
	}
    return base.Standalone.onWriteToSpriteTable(px, py, renderQueue)
}

// This is practically a different version of Standalone.drawCharacterSprite. You'll probably need custom rendering for Tails' Tails.
function bool MISC.drawCHARACTER_REIMU(u8 character, u8 variant, s16 px, s16 py, bool asSmallGhost) // you can change this name obviously, but you need to change the function that's called in the code above.
{
	bool isPlayer1 = (A0 == 0xffffb000)
	u32 characterAddress = A0
	
	// Check only needed for Tails' tails
	if (variant == 2)
	{
		// No smooth rotation in Slot Machine
		if (global.zone == 0x15)
			return false
		
		characterAddress = 0xffff0000 + u16[A0 + 0x30]

		// Do not render when blinking after hit
		if (u8[characterAddress + 0x34] != 0 && ((u8[characterAddress + 0x34] + 1) & 0x04) == 0)
			return false

		// Do not render when Tails looks into the background (e.g. LBZ 2 end cutscene) and in DEZ gravity transporters
		if (u8[characterAddress + 0x22] >= 0x55 && u8[characterAddress + 0x22] <= 0x5b)
			return false

		isPlayer1 = (characterAddress == 0xffffb000)
		character = CHARACTER_TAILS
	}

	if (level.vertical_wrap == 0xff00)
	{
		// For vertically wrapping levels, "normalize" py into interval [-move_area.bottom.target * 3/4, -move_area.bottom.target * 1/4]
		py &= level.height.bitmask
		if (py > move_area.bottom.target * 3/4 && move_area.bottom.target >= 0xe0)	// move_area.bottom.target is very low in DEZ boss act
			py -= move_area.bottom.target
	}

	u8 animationSprite = char.animation.sprite
	u16 animationSpriteEx = Standalone.getModdedAnimationSpriteEx(character, animationSprite)
	u8 flags = (char.render_flags & (SPRITE_FLAG_FLIP_X | SPRITE_FLAG_FLIP_Y))
	u8 angle = 0
	u64 key = Standalone.getModdedAnimationSpriteKey(character, animationSpriteEx)		// First ask modded scripts
	u8 rotationMode = 0

	if (variant < 2)
	{
		if (character == CHARACTER_SONIC && animationSpriteEx == animationSprite)	// Last check is only false if modded scripts made their own changes
		{
			// Special handling for Super Peel-Out
			if (animationSprite >= 0x21 && animationSprite <= 0x30)
			{
				if (sonic.fastrunanim.timer > 0)
				{
					animationSpriteEx = CHAR_ANIMSPRITE_SONIC_PEELOUT + (level.framecounter & 0x03)

					if (!Game.getSetting(SETTING_SMOOTH_ROTATION))
					{
						angle = (animationSprite - 0x21) / 4 * 0xe0
						if ((char.flags & char.flag.FACING_LEFT) == (global.inv_gravity == 0))
							angle = -angle
						animationSprite = 0x21 + (animationSprite - 0x21) % 4
					}
				}
			}
		}

		if !(Game.getSetting(SETTING_SMOOTH_ROTATION))
		{
			// Character
			if (animationSprite >= 0x01 && animationSprite <= 0x20)
			{
				// Walking animation
				angle = (animationSprite - 0x01) / 8 * 0xe0
				if ((char.flags & char.flag.FACING_LEFT) == (global.inv_gravity == 0))
					angle = -angle
				animationSprite = 0x01 + (animationSprite - 0x01) % 8
			}
			else if (animationSprite >= 0x21 && animationSprite <= 0x30)
			{
				if !(sonic.fastrunanim.timer > 0)
				{
				// Running animation
		        angle = (animationSprite - 0x21) / 4 * 0xe0
				if ((char.flags & char.flag.FACING_LEFT) == (global.inv_gravity == 0))
					angle = -angle
				animationSprite = 0x21 + (animationSprite - 0x21) % 4
				}
			}
			else if (animationSprite >= 0x78 && animationSprite <= 0x7f)
			{
				// Swinging animation
				angle = (animationSprite - 0x78) * 0xe0
				if ((char.flags & char.flag.FACING_LEFT) == (global.inv_gravity == 0))
					angle = -angle
				animationSprite = 0x78
			}
		}
		else if (Game.getSetting(SETTING_SMOOTH_ROTATION))
		{
			// Character
			if (animationSprite >= 0x01 && animationSprite <= 0x20)
			{
				// Walking animation
				animationSprite = 0x01 + (animationSprite - 0x01) % 8
				rotationMode = 1
			}
			else if (animationSprite >= 0x21 && animationSprite <= 0x30)
			{
				// Running animation
				animationSprite = 0x21 + (animationSprite - 0x21) % 4
				rotationMode = 1
			}
			else if (animationSprite >= 0x78 && animationSprite <= 0x7f)
			{
				// Swinging animation
				animationSprite = 0x78
				rotationMode = 2
			}
			else if (character == CHARACTER_TAILS && animationSprite >= 0xc3 && animationSprite <= 0xca)
			{
				// Tails' fastest run animation
				animationSprite = 0xc3 + (animationSprite - 0xc3) % 2
				rotationMode = 1
			}
			else if (character == CHARACTER_KNUCKLES && animationSprite == 0xc0)
			{
				// Only for DDZ
				rotationMode = 1
			}

			if (rotationMode != 0)
			{
			#if GAMEAPP >= 0x23032500
				bool useVanillaS3AIRRotation = true
				if (Game.getSetting(SETTING_SMOOTH_ROTATION) == 2)
				{
					useVanillaS3AIRRotation = (char.flags & char.flag.IN_AIR || global.zone == 0x0c)	// Use in-air rotation in DDZ
				}

				if (useVanillaS3AIRRotation)
			#endif
				{
					s8 oldRotation = isPlayer1 ? oldRotationPlayer1 : oldRotationPlayer2
					flags = char.flags & char.flag.FACING_LEFT		// This really has to be "char.flags", not "char.render_flags"

					angle = char.rotation
					if (rotationMode == 1)
					{
						if (abs(s8(char.rotation)) <= 0x10 && abs(oldRotation) <= 0x10)
						{
							angle = 0
						}

						if (angle != char.rotation)
						{
							s8 diff = angle - oldRotation
							angle = oldRotation + clamp(diff, -3, 3)
						}
					}	
				}
			#if GAMEAPP >= 0x23032500
				else
				{
					// Mania-accurate rotation #contributed by Elsie The Pict
					u8 oldRotation = isPlayer1 ? oldRotationPlayer1 : oldRotationPlayer2
					flags = char.flags & char.flag.FACING_LEFT		// This really has to be "char.flags", not "char.render_flags"

					angle = char.rotation
					if (rotationMode == 1)
					{
						
						if (char.rotation <= 0x04 || char.rotation >= 0xfc)
							oldRotation = 0
						else
						{
							u32 targetRotation = 0
							if (char.rotation > 0x10 && char.rotation < 0xe8)
								targetRotation = char.rotation
								
							u32 rotate = targetRotation - oldRotation
							u32 shift = (abs(char.groundspeed) <= 0x6000) + 1
							
							if (abs(rotate) >= abs(rotate - 0x100))
							{
								if (abs(rotate - 0x3) < abs(rotate + 0x100))
									oldRotation += (rotate - 0x100) >> shift
								else
									oldRotation += (rotate + 0x100) >> shift
							}
							else
							{
								if (abs(rotate) < abs(rotate + 0x100))
									oldRotation += rotate >> shift
								else
									oldRotation += (rotate + 0x100) >> shift
							}
						}
						
						angle = oldRotation
						angle &= 0xFF
					}
				}
			#endif
			}
			
			if (isPlayer1)
				oldRotationPlayer1 = angle
			else
				oldRotationPlayer2 = angle
		}

		constant array<u8> MISCsidewaysCorkscrewSprites =
		{
			0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x31, 0x32, 0x33, 0x34, 0x35
		}
		constant array<u8> MISCangledCorkscrewSprites =
		{
			0x37, 0x36, 0x35, 0x34, 0x33, 0x32, 0x31, 0x3c, 0x3b, 0x3a, 0x39, 0x38
		}
		if (animationSprite >= 0x6c && animationSprite <= 0x77) //sideways Corkscrew (AIZ tree, CNZ helix thing)
		{
			bool onThatFuckingObject = objA0.state.both == char.state.RUNNING2 // more specifically, FBZ2 vertical cylinders that spin
			
			animationSprite = MISCsidewaysCorkscrewSprites[animationSprite-0x6c]
			angle = onThatFuckingObject ? 0x40 : -0x40
			if (!onThatFuckingObject)
				flags ^= SPRITE_FLAG_FLIP_Y
			else if (flags & SPRITE_FLAG_FLIP_Y)
				flags ^= SPRITE_FLAG_FLIP_Y
			else
				flags ^= SPRITE_FLAG_FLIP_X
		}
		if (animationSprite >= 0x49 && animationSprite <= 0x54) //angled Corkscrew (CNZ barber pole)
		{
			animationSprite = MISCangledCorkscrewSprites[animationSprite-0x49]
			angle = char.flags2d == 0x02 ? 0x20 : -0x20
			bool goingOppositeDirection = char.flags2d == 0x02 ? (flags & SPRITE_FLAG_FLIP_X) : !(flags & SPRITE_FLAG_FLIP_X)
			if (goingOppositeDirection)
				angle += 0x80
			if (char.rotation == 0) // bug with CNZ fans, entering FBZ vertical cylinder for some reason
			{
				angle = char.flags2d == 0 ? 0xa0 : 0x20
				if (char.flags2d == 0) // reverse it with FBZ vertical cylinders
					flags ^= SPRITE_FLAG_FLIP_X
			}
			else // normal stuff
			{
				flags |= SPRITE_FLAG_FLIP_Y
				if (goingOppositeDirection)
				{
					if (flags & SPRITE_FLAG_FLIP_X)
						flags &= ~SPRITE_FLAG_FLIP_X
					else
						flags |= SPRITE_FLAG_FLIP_X
				}
			}
		}
		
		if (isPlayer1)
			timeattack.animSpriteEx = animationSpriteEx

		if (key == 0)
		{
			key = MISC.GetCharSpriteKey(animationSprite, MISC.player) //custom sprite key

			if (!Renderer.hasCustomSprite(key))
			{
				u32 sourceBase    = (character == CHARACTER_SONIC) ? ((animationSprite >= 0xda) ? 0x140060 : 0x100000) : (character == CHARACTER_TAILS) ? ((animationSprite >= 0xd1) ? 0x143d00 : 0x33e0) : 0x13e0
				u32 tableAddress  = (character == CHARACTER_SONIC) ? 0x148182 : (character == CHARACTER_TAILS) ? 0x14a08a : 0x14bd0a
				u32 mappingOffset = (character == CHARACTER_SONIC) ? 0x146620 : (character == CHARACTER_TAILS) ? 0x148eb8 : 0x14a8d6		// Not really necessary here, we could also use "char.mapping_offset"

				key = Renderer.setupCustomCharacterSprite(sourceBase, tableAddress, mappingOffset, animationSprite, 0x00)
			}
		}

	}
	else
	{
		if (Game.getSetting(SETTING_SMOOTH_ROTATION))
		{
			// Tails' tails
			if (animationSprite >= 0x05 && animationSprite <= 0x14)
			{
				animationSprite = 0x05 + (animationSprite - 0x05) % 4
				angle = lookupAngleByVector(s16[characterAddress + 0x18], s16[characterAddress + 0x1a])

				flags = 0
				if (char.flags & char.flag.FACING_LEFT)
				{
					flags |= SPRITE_FLAG_FLIP_X
					angle += 0x80
				}
				if (global.inv_gravity)
				{
					flags ^= SPRITE_FLAG_FLIP_Y
					angle = -angle
				}
			}
		}

		key = stringformat(stringformat("%s_tails_0x%02x", getCharacterSpriteKey(CHARACTER_TAILS)), animationSprite)
		if (!Renderer.hasCustomSprite(key))
		{
			key = Renderer.setupCustomCharacterSprite(0x336620, 0x344d74, 0x344bb8, animationSprite, 0x00)
		}
	}

	u16 renderQueue = 0xa000 - char.sprite_priority
	
	if A0 != 0xffffb000
		renderQueue -= 1
	
	u8 atex = (char.sprite_attributes >> 9) & 0x30
	if (EXTENDED_CHARACTER_PALETTES)
	{
		u8 player
		if variant == 2
			player = (u16[A0 + 0x30] == 0xb000) ? 0 : (u16[A0 + 0x30] == 0xb04a) ? 1 : (u16[A0 + 0x30] == 0xc2ca) ? 2 : 3
		else
			player = (A0 == 0xffffb000) ? 0 : (A0 == 0xffffb04a) ? 1 : (A0 == 0xffffc2ca) ? 2 : 3
		
		atex = 0x40 + player * 0x20
	}

	if (char.sprite_attributes & sprite_attribute.PRIORITY)
		flags |= SPRITE_FLAG_PRIO

	if (rotationMode != 0 && global.inv_gravity)
	{
		// Correction for inverse gravity
		angle = 128 - angle
		flags ^= SPRITE_FLAG_FLIP_X
	}
	
	// Render character
	if (asSmallGhost)
	{
		Renderer.drawSpriteTinted(key, px, py, atex, flags | SPRITE_FLAG_PRIO, 0xa800, angle, 0xffffffc0, 0x8000)
	}
	else
	{
		Renderer.drawSprite(key, px, py, atex, flags, renderQueue, angle, 255)
	}

	bool useAfterImages
	if (isPlayer1)
	{
		if ((super.active == 0xff) || (super.active.tails == 0xff))
		{
			useAfterImages = true
		}
		else if (Game.getSetting(SETTING_SPEEDUP_AFTERIMGS))
		{
			useAfterImages = ((u8[characterAddress + 0x2b] & char.bonus.SPEED_UP) != 0)
		}
	}

	if (useAfterImages)
	{
		// Additional offset for Sonic charging a Super Peel-Out (either Hyper Sonic or with Speed Shoes)
		s16 afterImagesOffsetX = 0
		if (char.character == CHARACTER_SONIC && char.spindash == 0x80)
		{
			afterImagesOffsetX = (char.groundspeed >> 7) * ((char.flags & char.flag.FACING_LEFT) ? 1 : -1)
		}

		for (s8 i = 3; i > 0; --i)
		{
			A1 = 0xffffe500 + u8(posbackup.offset.player1 - (i * 8 + 4))
			s16 px0 = u16[A1] - camera.foreground.x.u16 + (i * afterImagesOffsetX / 4)
			s16 py0 = u16[A1+2] - camera.foreground.y.u16
			if (level.vertical_wrap == 0xff00)	// Consider vertical level wrap
				py0 &= level.height.bitmask
			
			Renderer.drawSprite(key, px0, py0, atex, flags, renderQueue - i, angle, 192 - i * 32)
		}
	}
	return true
}