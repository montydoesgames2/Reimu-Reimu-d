
#define MISC_SPECIALPLAYERS_ADDON

function void MISC.SpawnSpecialPlayer()
{
	if global.characters == CHARACTER_REIMU //prevent looping by putting if statement here
	{
		
		return
	}
	
	base.MISC.SpawnSpecialPlayer()
}

function bool MISC.SpawnSpecialPlayer2()
{
	MISC.player2.character = CHARACTER_TAILS

	if global.characters == CHARACTER_REIMU && (global.zone >= 0x0a) && (global.zone <= 0x0c)
	{
		u32[0xffffb04a] = addressof(Character.BaseUpdate.MISCPartner)
		u16[0xffffb04a + 0x10] = u16[0xffffb000 + 0x10] - 0x20
		u16[0xffffb04a + 0x14] = u16[0xffffb000 + 0x14] + 4
		u32[0xffffcc9e] = 0x018b3e
		tails.ai_routine = 0
		//set player 2 as partner
		MISC.setPlayer(2, CHARACTER_SONIC) //this can literally be any MISC character, even the same as player 1.
		return true
	}
	
	return base.MISC.SpawnSpecialPlayer2()
}

function void MISC.setPlayer(u8 player, u8 character)
{
	u32 A0backup = A0
	//tag team support
	A0 = (player == 1) ? 0xffffb000 : (player == 2) ? 0xffffb04a : (player == 3) ? 0xffffc2ca : 0xffffc314
	
	MISC.player = character
	if player == 2
		MISC.player2.character = character
	A0 = A0backup
}

//Check if A0 is the selected player
function bool MISC.isPlayer(u8 player)
{
	//tag team compat
	u8 check = (A0 == 0xffffb000) ? 1 : (A0 == 0xffffb04a) ? 2 : (A0 == 0xffffc2ca) ? 3 : 4
	
	if check == player
		return true
	return false
}

//get the current player in a certain player slot DURING STAGES
function bool MISC.getCharacter(u8 player, u8 character)
{
	if character < 4 //not a MISC char
	{
		u32 A0backup = A0
		//tag team support
		A0 = (player == 1) ? 0xffffb000 : (player == 2) ? 0xffffb04a : (player == 3) ? 0xffffc2ca : 0xffffc314
		
		if char.character == character
			return true
			
		A0 = A0backup
	}

	if player == 1
	{
		if global.characters == character
			return true
	}
	else
	{
		u32 A0backup = A0
		//tag team support
		A0 = (player == 2) ? 0xffffb04a : (player == 3) ? 0xffffc2ca : 0xffffc314
		
		if MISC.player == character
			return true
		
		A0 = A0backup
	}
	
	return false
}

//Checks if current player at selected address is the character
function bool MISC.isCharacter(u32 address, u8 character)
{
	u32 A0backup = A0
	A0 = address

	if character < 4 //not a MISC char
	{
		if char.character == character
		{
			A0 = A0backup
			return true
		}
	}

	if A0 == 0xffffb000
	{
		if global.characters == character
		{
			A0 = A0backup
			return true
		}
	}
	else
	{
		if MISC.player == character
		{
			A0 = A0backup
			return true
		}
	}
	
	A0 = A0backup
	
	return false
}

define MISC.player = u8[A0 + 0x29]

//You can change this address
//do NOT edit any of the code unless you change this address
//# address-hook(0x1f0a94)
function void Character.BaseUpdate.MISCPartner()
{
	//correct spindash stuff in post
	u8 SpindashOffset = (MISC.getCharBase(MISC.player2.character) != CHARACTER_TAILS) ? 0 : 1
	if u8[0xffffcc9e + 0x38] != SpindashOffset
		u8[0xffffcc9e + 0x38] = SpindashOffset
		
	A4 = addressof(global.move.speedcap.tails)	// Address: 0xfffff760 = Base address of speed caps & acceleration/deceleration
	A5 = addressof(camera.yoffset.tails)	// Address: 0xffffee2c
	A6 = 0xffffcc9e							// Base address of dust cloud object
	
	if MISC.getCharBase(MISC.player2.character) == CHARACTER_SONIC
	{
		if char.character != CHARACTER_SONIC
			char.base_state = 0

		// Targets:
		//	- 0x010afa	-> char.base_state = 0x00 = base_state.INITIAL	-> Character.Initialization.Sonic()		-> Initialization
		//	- 0x010bba	-> char.base_state = 0x02 = base_state.NORMAL	-> Character.UpdateNormalState.Sonic()	-> In normal state
		//	- 0x0122be	-> char.base_state = 0x04 = base_state.HURT		-> Character.UpdateGotHurtState.Sonic()	-> Sonic just got hurt
		//	- 0x012390	-> char.base_state = 0x06 = base_state.DIED		-> Character.UpdateDiedState.Sonic()	-> Sonic died
		//	- 0x01257c	-> char.base_state = 0x08 = base_state.INACTIVE	-> Character.UpdateRestartDelay()		-> Completely inactive after death
		//	- 0x0125ac	-> char.base_state = 0x0c = base_state.DROWNED	-> Character.UpdateDrownedState.Sonic()	-> Sonic died by drowning
		
		if char.base_state == 0x02
		{
			// Tails is the second player
			if (player2.control_override == 0)
			{
				control.misc.pad2 = control.pad2
			}

			if (player2.control_override >= 0 && competition_mode.active == 0)
			{
				Character.TailsAI.Update()
			}
		}
		
		call tableLookupAddress(0x010aec, char.base_state)
	}
	else if MISC.getCharBase(MISC.player2.character) == CHARACTER_KNUCKLES
	{
		if char.character != CHARACTER_KNUCKLES
			char.base_state = 0

		// Targets:
		//  - 0x0164aa	-> char.base_state = 0x00 = base_state.INITIAL	-> Character.Initialization.Knuckles()		-> Initialization
		//  - 0x01656c	-> char.base_state = 0x02 = base_state.NORMAL	-> Character.UpdateNormalState.Knuckles()	-> In normal state
		//  - 0x017bb6	-> char.base_state = 0x04 = base_state.HURT		-> Character.UpdateGotHurtState.Knuckles()	-> Knuckles just got hurt
		//  - 0x017c88	-> char.base_state = 0x06 = base_state.DIED		-> Character.UpdateDiedState.Knuckles()		-> Knuckles died
		//  - 0x017cba	-> char.base_state = 0x08 = base_state.INACTIVE	-> Character.UpdateRestartDelay()			-> Completely inactive after death
		//  - 0x017cea	-> char.base_state = 0x0c = base_state.DROWNED	-> Character.UpdateDrownedState.Knuckles()	-> Knuckles died by drowning
		
		if char.base_state == 0x02
		{
			// Tails is the second player
			if (player2.control_override == 0)
			{
				control.misc.pad2 = control.pad2
			}

			if (player2.control_override >= 0 && competition_mode.active == 0)
			{
				Character.TailsAI.Update()
			}
		}
		
		call tableLookupAddress(0x01649c, char.base_state)
	}
	else
	{
		if char.character != CHARACTER_TAILS
			char.base_state = 0
	
		// Check for debug mode
		if (debug_mode.state == 0 || !isMainCharacter(CHARACTER_TAILS))	// Maybe a check if it's second player Tails?
		{
			// Targets:
			//  - 0x0136ca	-> char.base_state = 0x00 = base_state.INITIAL	-> Character.Initialization.Tails()		-> Initialization
			//  - 0x0137c4	-> char.base_state = 0x02 = base_state.NORMAL	-> Character.UpdateNormalState.Tails()	-> In normal state
			//  - 0x01569c	-> char.base_state = 0x04 = base_state.HURT		-> Character.UpdateGotHurtState.Tails()	-> Tails just got hurt
			//  - 0x01578e	-> char.base_state = 0x06 = base_state.DIED		-> Character.UpdateDiedState.Tails()	-> Tails died
			//  - 0x0157e0	-> char.base_state = 0x08 = base_state.INACTIVE	-> Character.UpdateRestartDelay()		-> Completely inactive after death
			//  - 0x015810	-> char.base_state = 0x0c = base_state.DROWNED	-> Character.UpdateDrownedState.Tails()	-> Tails died by drowning
			call tableLookupAddress(0x0136bc, char.base_state)
		}
		else if (updateDebugModeRegular())
		{
			UpdateTailsSpritePatterns()
			DrawObject()
		}
	}
	
	//force a respawn a certain distance away from player 1
	
	u32 A1backup = A1
	A1 = 0xffffb000
	//MATH TIME
	float d = Math.sqrt(Math.sqr(abs((objA1.position.x.u16 - objA0.position.x.u16))) + Math.sqr(abs((objA1.position.y.u16 - objA0.position.y.u16))))
	A1 = A1backup
	
	if d > 2000.0 && player2.control_override == 0 && global.level_started && char.control_flags == 0
	{
		// Second player Tails
		char.base_state = base_state.NORMAL
		RespawnTails()
	}
}

function void updateCharacterSpritePatterns(u8 character, u8 animationSprite)
{
	if objA0.update_address != addressof(Character.BaseUpdate.MISCPartner)
	{
		base.updateCharacterSpritePatterns(character, animationSprite)
		return
	}
}

function bool Standalone.onWriteToSpriteTable(s16 px, s16 py, u16 renderQueue)
{
	bool prioFlag = (objA0.sprite_attributes & sprite_attribute.PRIORITY) != 0
	
	// Characters in special stage
	if (objA0.update_address == 0x00927a) && MISC.player2.character == CHARACTER_SONIC && global.characters == CHARACTER_REIMU
	{
		//This just uses the base MISC character's sprite key.
	
		u8 character = (objA0.update_address == 0x00927a) ? MISC.player2.character : MISC.player1.character
		u8 atex = (character == CHARACTER_TAILS) ? 0x10 : 0x00
		u64 key = stringformat(stringformat("%s_0x%02x", getCharacterBluesphereSpriteKey(character)), objA0.animation.sprite)
		if (Renderer.hasCustomSprite(key))
		{
			// Check if there's also a custom palette
			string paletteKey = getCharacterBluespherePaletteKey(character)
			if (System.hasExternalPaletteData(paletteKey, 0))
			{
				atex = 0x40 + character * 0x20
			}
			
			u16 numColors = System.loadExternalPaletteData(paletteKey, 0, 0x800000, 0x20)
			if (numColors > 0)
			{
				u32 dest = 0x802180 + 0x40
				for (u16 i = 0; i < numColors; ++i)
				{
					if u16[dest + i * 2] != packColor(u32[0x800000 + i * 4])
						u16[dest + i * 2] = packColor(u32[0x800000 + i * 4])
				}
			}
		}
		else //FAILSAFE, use base characters' sprites.
		{
			character = getSecondCharacter()
			atex = (character == CHARACTER_TAILS) ? 0x10 : 0x00
			if (character == CHARACTER_SONIC)
				key = Renderer.setupCustomCharacterSprite(0x0aaa7c, 0x0abe14, 0x000abdfc, objA0.animation.sprite, atex)
			else if (character == CHARACTER_TAILS)
				key = Renderer.setupCustomCharacterSprite(0x28f95a, 0x2908d2, objA0.mapping_offset, objA0.animation.sprite, atex)
			else
				key = Renderer.setupCustomCharacterSprite(0x0abf22, 0x0ad31a, 0x0ad302, objA0.animation.sprite, atex)

			if (ROMDataAnalyser.isEnabled())
				Renderer.extractCustomSprite(key, getCharacterBluesphereSpriteKey(character), objA0.animation.sprite, atex)
		}
		Renderer.drawCustomSprite(key, px, py, atex, prioFlag ? SPRITE_FLAG_PRIO : 0, renderQueue)
		return true
	}
	
	// Tails' tails object in special stage
	if (objA0.update_address == 0x009488) && MISC.player2.character == CHARACTER_SONIC && global.characters == CHARACTER_REIMU
	{
		//Either change it or just do nothing and just return true. if your character HAS tails' tails for... some reason?? you can just remove this.
		return true
	}
	
	return base.Standalone.onWriteToSpriteTable(px, py, renderQueue)
}

//Draw the 2nd player and their tails.
function bool Standalone.drawCharacterSprite(u8 character, u8 variant, s16 px, s16 py, bool asSmallGhost)
{
	//base player
	if u8[0xffffb000 + 0x29] < 4 && (A0 == 0xffffb000 || (A0 == tailstails.p1 && u8[0xffffb000 + 0x29] < 4))
		return base.Standalone.drawCharacterSprite(character, variant, px, py, asSmallGhost)

	//player 2
	if (A0 == 0xffffb04a || A0 == tailstails.p2) && u8[0xffffb04a + 0x29] > 3
	{
		return MISC.drawCharacterSprite(character, u8[0xffffb04a + 0x29], variant, px, py, asSmallGhost)
	}
		
	return base.Standalone.drawCharacterSprite(character, variant, px, py, asSmallGhost)
}

//Don't allow partner super transformations
function bool Character.performSuperTransformation()
{
	//Log = A0
	if objA0.update_address != addressof(Character.BaseUpdate.MISCPartner)
		return base.Character.performSuperTransformation()
	return false
}

//Don't allow partners to cancel super transformation
function void Character.cancelSuperTransformation()
{
	if objA0.update_address != addressof(Character.BaseUpdate.MISCPartner)
		base.Character.cancelSuperTransformation()
}

//spawn the character
function void Character.Initialization.shared(u8 character)
{
	base.Character.Initialization.shared(character)
	
	if objA0.update_address != addressof(Character.BaseUpdate.MISCPartner)
		return
		
	if MISC.player > CHARACTER_KNUCKLES
	{
		MISC.SetCharHitbox(2)
	}

	if (isMainCharacter(CHARACTER_TAILS)) //fix the layers
	{
		if (checkpoint.number == 0)
		{
			char.sprite_attributes = (Char.Tails.targetInVRAM >> 5)
			char.layer_flags1 = 0x0c
			char.layer_flags2 = 0x0d

			if (global.stage_type != 2)
			{
				checkpoint.x = char.position.x.u16
				checkpoint.y = char.position.y.u16
				checkpoint.sprite_attr = char.sprite_attributes
				checkpoint.layer_flags = char.layer_flags
			}
		}
	}
	else
	{
		char.sprite_attributes = (Char.Tails.targetInVRAM >> 5) | (u16[0xffffb000 + 0x0a] & sprite_attribute.PRIORITY)
		char.layer_flags = u16[0xffffb000 + 0x46]
	}

	super.active.tails = 0

	if (tails.ai_routine != 0x12 && tails.ai_routine != 0x20)
		tails.ai_routine = 0

	tails.control_counter = 0
	tails.respawn_counter = 0

	//choose whether or not to keep tails' tails.
	if (character == CHARACTER_TAILS)
	{
		// Init Tails' tails object
		if A0 == 0xffffb000
		{
			u32[tailstails.p1] = addressof(TailsTails.Init)
			u16[tailstails.p1 + 0x30] = 0xb000
		}
		else if A0 == 0xffffb04a
		{
			//either delete player 1's tail or set it to update for p1
			if MISC.getCharBase((u8[0xffffb000 + 0x29] > 3) ? u8[0xffffb000 + 0x29] : u8[0xffffb000 + 0x29]-1) == CHARACTER_TAILS
				u16[tailstails.p1 + 0x30] = 0xb000
			else
				u32[tailstails.p1] = 0
		
			u32[tailstails.p2] = addressof(TailsTails.Init)
			u16[tailstails.p2 + 0x30] = 0xb04a
		}
		else if A0 == 0xffffc2ca
		{
			u32[tailstails.p3] = addressof(TailsTails.Init)
			u16[tailstails.p3 + 0x30] = 0xc2ca
		}
		else if A0 == 0xffffc314
		{
			u32[tailstails.p4] = addressof(TailsTails.Init)
			u16[tailstails.p4 + 0x30] = 0xc314
		}
	}
	else
	{
		// Init Tails' tails object
		if A0 == 0xffffb000
		{
			u32[tailstails.p1] = 0
		}
		else if A0 == 0xffffb04a
		{
			u32[tailstails.p2] = 0	
		}
		else if A0 == 0xffffc2ca
		{
			u32[tailstails.p3] = 0
		}
		else if A0 == 0xffffc314
		{
			u32[tailstails.p4] = 0
		}
	}
	
	checkpoint.number.backup.tails = checkpoint.number
}

function bool onCharacterPressedJumpInMidAir(u8 input_state, u8 input_pressed)
{
	u32 A0backup = A0
	A0 = 0xffffb04a
	if objA0.update_address != addressof(Character.BaseUpdate.MISCPartner) //only do tails assist if the player IS tails.
	{
		A0 = A0backup
		return base.onCharacterPressedJumpInMidAir(input_state, input_pressed)
	}
	A0 = A0backup
	
	//you can put unique interactions here
	
	//don't allow normal double jump moves
	if objA0.update_address == addressof(Character.BaseUpdate.MISCPartner)
		return false

	// Use normal jump button reaction
	return true
}

//Change how the AI for partners is initialised
//# address-hook(0x013a10) end(0x013b24)
function void Character.TailsAI.Init()
{
    if (checkpoint.number.backup.tails == 0) && objA0.update_address == addressof(Character.BaseUpdate.MISCPartner)   // This is some checkpoint number backup for Tails
    {
        bool isKnucklesIntro = (Game.getSetting(SETTING_AIZ_INTRO_KNUCKLES) != 0 && isMainCharacter(CHARACTER_KNUCKLES) && checkpoint.number == 0 && !Game.isTimeAttack())
        if (global.zone_act == 0x0000 && !isSonicIntro() && !isKnucklesIntro)        // AIZ 1
        {
            char.state = char.state.RUNNING
            char.velocity.x = 0
            char.velocity.y = 0
            char.groundspeed = 0
            char.flags = 0
            char.control_flags = 0
            tails.respawn_counter = 0
            tails.ai_routine = 0x06
            return
        }
		else if ((global.zone_act == 0x0300) || (global.zone_act == 0x0700 && global.lock_on_state == 0)) && !SpawnAITails(global.characters)		// CNZ 1
		{
			char.state = (global.zone_act == 0x0700) ? char.state.GOT_HURT_PANIC : char.state.RUNNING
			char.velocity.x = 0
			char.velocity.y = 0
			char.groundspeed = 0
			char.flags = (global.zone_act == 0x0700) ? char.flag.IN_AIR : 0
			char.control_flags = 0
			tails.respawn_counter = 0
			tails.ai_routine = 0x06
			return
		}
    }

    base.Character.TailsAI.Init()
}

//Respawn the partner
//# address-hook(0x013bf8) end(0x013d48)
function void fn013bf8()
{
	if u32[0xffffb04a] != addressof(Character.BaseUpdate.MISCPartner)
	{
		base.fn013bf8()
		return
	}
	
	char.rotation = 0
	
	//These are the interactions for each character when they respawn.
	//Tails flies down, sonic just falls, and knuckles glides down.
	//You can change these, since it's pretty much all that matters
	if (objA0.render_flags & render_flag.VISIBLE)
	{
		if char.character == CHARACTER_SONIC
		{
			UpdateMovementStraight()
			char.velocity.y += 0x38
			char.flags |= char.flag.IN_AIR
			char.state = char.state.ROLLING
		}
		else if char.character == CHARACTER_TAILS
		{
			tails.flight_countdown = 0xf0
			char.flags |= char.flag.IN_AIR
			UpdateTailsFlight_innerB()
			tails.respawn_counter = 0
		}
		else
		{
			UpdateKnucklesGlide()
		}
		
		char.sprite_priority = objA1.sprite_priority
		char.control_flags &= ~(control_flag.DISABLE_ANIMATION | control_flag.DISABLE_UPDATE)
		char.control_flags |= control_flag.DISABLE_WALLS
	}
	
	D3.u8 = posbackup.offset.player1 - 0x44
	tails.flight_target.x = u16[0xffffe500 + D3.u8]
	tails.flight_target.y = u16[0xffffe500 + D3.u8 + 2]

	s16 dx = char.position.x.u16 - tails.flight_target.x
	if (dx != 0)
	{
		s16 moveX = min(abs(dx) >> 4, 12)
		moveX += abs(objA1.velocity.x) + 1
		if (dx >= 0)
		{
			char.flags |= char.flag.FACING_LEFT
			if (moveX >= dx)
			{
				moveX = dx
				dx = 0
			}
			char.position.x.u16 -= moveX
		}
		else
		{
			char.flags &= ~char.flag.FACING_LEFT
			dx = -dx
			if (moveX >= dx)
			{
				moveX = dx
				dx = 0
			}
			char.position.x.u16 += moveX
		}
	}

	s16 dy = char.position.y.u16 - tails.flight_target.y
	if (dy != 0)
	{
	#if STANDALONE
		// Consider vertical level wrap
		if (level.vertical_wrap == 0xff00)
		{
			dy &= level.height.bitmask
			if (dy > level.height.bitmask / 2)
				dy -= (level.height.bitmask + 1)
		}
	#endif
		char.position.y.u16 += (dy > 0) ? -1 : 1
	}

	D2.u8 = u8[0xffffe400 + D3.u8 + 2] & 0x80
	if (D2.u8 == 0 && u8[0xffffb000 + 0x05] < base_state.DIED)
	{
	#if STANDALONE
		// Let Tails drop down when close enough to either the target point or the main character's current position
		bool gainControlNow = (char.character != CHARACTER_SONIC) ? (abs(dx) <= 4 && abs(dy) <= 4) : (dy >= -4)
		gainControlNow = gainControlNow || (abs(objA1.position.x.u16 - char.position.x.u16) <= 4 && abs(objA1.position.y.u16 - char.position.y.u16) <= 4)

		// Allow for pressing a jump button to gain control over Tails at once
		gainControlNow = gainControlNow || (control.misc.pad2.pressed & CONTROL_ABC)
	#else
		bool gainControlNow = (dx == 0 && dy == 0)
	#endif

		if (gainControlNow)
		{
			if char.character != CHARACTER_SONIC
			{
				char.velocity.x = 0
				char.velocity.y = 0
			}
		
			tails.ai_routine = 0x06
			char.control_flags = 0
			char.state = char.state.RUNNING
			char.groundspeed = objA1.groundspeed
			char.flags &= char.flag.UNDERWATER
			char.flags |= char.flag.IN_AIR
			char.hlock_countdown = 0
			char.sprite_attributes = (char.sprite_attributes & ~sprite_attribute.PRIORITY) | (objA1.sprite_attributes & sprite_attribute.PRIORITY)
			char.layer_flags1 = u8[A1 + 0x46]
			char.layer_flags2 = u8[A1 + 0x47]

			if (gainControlNow)
			{
				// Roll instead
				char.state = char.state.ROLLING
			}
			return
		}
	}
	char.control_flags = (control_flag.DISABLE_INTERACTION | control_flag.DISABLE_UPDATE)
}

//Don't drain rings
//# address-hook(0x011b26) end(0x011bdc)
function void Character.UpdateRingsInSuperForm()
{
	if objA0.update_address != addressof(Character.BaseUpdate.MISCPartner)
	{
		base.Character.UpdateRingsInSuperForm()
		return
	}
}

//Don't kill restart on player 2 dying
//# address-hook(0x0123c2) end(0x01257a)
function void Character.CheckDiedStateEnd()
{
	if (objA0.update_address == addressof(Character.BaseUpdate.MISCPartner)) && objA0.position.y.u16 > camera.position.y.u16 + getScreenHeight()/2
	{
		// Second player Tails
		char.base_state = base_state.NORMAL
		RespawnTails()
	}
	else
		base.Character.CheckDiedStateEnd()
}

//player 2's underwater checks
function void Character.checkForWaterSurface()
{
	if objA0.update_address != addressof(Character.BaseUpdate.MISCPartner)
	{
		base.Character.checkForWaterSurface()
		return
	}

	if (!level.water_present)
		return

	bool wasUnderwaterBefore = (char.flags & char.flag.UNDERWATER) != 0
	bool isUnderwaterNow = (s16(char.position.y.u16) > s16(water.height.current))
	if (isUnderwaterNow == wasUnderwaterBefore)
		return

	++water.transition_counter
	A1 = A0
	UpdateMusicOnWaterTransition()

	bool isSuperActive = super.active
	bool controlFlag = (char.control_flags == 0)
	if (char.character == CHARACTER_TAILS)
	{
		isSuperActive = super.active.tails
		controlFlag = (tails.ai_routine == 4) || (char.control_flags == 0)
	}

	if (isUnderwaterNow)
	{
		char.flags |= char.flag.UNDERWATER

		// Spawn underwater update object
		u32[0xffffcb76] = addressof(UnderwaterUpdate.BaseUpdate)
		u8[0xffffcb76 + 0x2c] = 0x81
		u32[0xffffcb76 + 0x40] = A0
		

		if (controlFlag)
		{
			char.velocity.x >>= 1
			char.velocity.y >>= 2
			if (char.velocity.y != 0)
			{
				// Set state of dust cloud object to 0x01
				u16[A6 + 0x20] = 0x0100
				playSound(SFX_WATERSPLASH)
			}
		}

	#if STANDALONE
		// Update achievement
		if (A0 == 0xffffb000)
		{
			Game.setAchievementValue(ACHIEVEMENT_LBZ_STAY_DRY, 0)
		}
	#endif
	}
	else
	{
		char.flags &= ~char.flag.UNDERWATER

		if (controlFlag && char.base_state != base_state.HURT)
		{
			if (char.velocity.y >= -0x400)
			{
				char.velocity.y *= 2
			}
		}

		if (char.state != char.state.DISAPPEARED && char.velocity.y != 0)
		{
			// Set state of dust cloud object to 0x01
			u16[A6 + 0x20] = 0x0100
			char.velocity.y = max(char.velocity.y, -0x1000)
			playSound(SFX_WATERSPLASH)
		}
	}

	// Update physics
	setSpeedCapProperties(A4)
}

//Load player 2's palette
function void copyPaletteDataFromTable(u8 index, u16 ramAddress)
{
	base.copyPaletteDataFromTable(index, ramAddress)
	
	if global.characters != CHARACTER_REIMU
		return
	
	u32 dest += ramAddress - 0xfc00				// With this, dest can be changed to non-faded palette and/or secondary palette
	if (EXTENDED_CHARACTER_PALETTES)
	{
		u8 paletteVariant = 0xff
		if (index == 0x03 || index == 0x05)
		{
			paletteVariant = 0
		}
		else if (index == 0x2b || index == 0x2c)
		{
			paletteVariant = 1		// AIZ underwater
		}
		else if (index == 0x39)
		{
			paletteVariant = 2		// ICZ underwater
		}
		else if (index == 0x31 || index == 0x32)
		{
			paletteVariant = 3		// HCZ underwater
		}
		else if (index == 0x2d  || index == 0x2e || index == 0x3a)
		{
			paletteVariant = 4		// CNZ/LBZ underwater
		}

		if (paletteVariant != 0xff)
		{
			u32 A0backup = A0
			//If for whatever reason you need to load a base character's palette, just check for this, and return base in getCharacterPaletteKey()
			A0 = 0x69696968
		
			u8 char = MISC.player2.character
			u8 offset = isMainCharacter(CHARACTER_TAILS) ? 0x40 : 0
			
			if (paletteVariant == 0)
			{
				// Load all characters' normal (non-underwater) palettes, either to fading or non-fading palette buffer
				dest = (ramAddress == 0xfc00) ? 0x802000 : 0x802180
				loadCharacterPalette(char,    dest + 0x40 - offset, 0)
			}
			else
			{
				// Load all characters' underwater palettes, either to fading or non-fading palette buffer
				dest = (ramAddress == 0xf080) ? 0x802300 : 0x802480
				loadCharacterPalette(char,    dest + 0x40 - offset, paletteVariant)
			}
			
			A0 = A0backup
		}
	}
}

function void fn0218ce()
{
	if objA1.update_address != addressof(Character.BaseUpdate.MISCPartner)
		base.fn0218ce()
		
	DrawObject()
}

//fix debug mode
function bool updateDebugModeInput(bool playingAsTails)
{
	if objA0.update_address != addressof(Character.BaseUpdate.MISCPartner)
		return base.updateDebugModeInput(playingAsTails)
	return false
}

//# address-hook(0x092ad4) end(0x092c52)
function void DebugMode.EvaluateInput()
{
	if objA0.update_address != addressof(Character.BaseUpdate.MISCPartner)
		base.DebugMode.EvaluateInput()
}

//Correct bluespheres colours
function void copyMemory(u32 destAddress, u32 sourceAddress, u32 bytes)
{
	base.copyMemory(destAddress, sourceAddress, bytes)
	if sourceAddress == 0x00896e && MISC.getCharBase(MISC.player2.character) == CHARACTER_KNUCKLES
	{
		base.copyMemory(0xfffffc90, 0x0089ee, 0x10)
	}
}

//fix ssz bar
//# address-hook(0x0453e6) end(0x045526)
function void fn0453e6()
{
    if (objA1.update_address != addressof(Character.BaseUpdate.MISCPartner)) || (u8[A1 + 0x38] == CHARACTER_TAILS)
    {
        base.fn0453e6()
        return
    }
    if (D1 == 0x11)
        D1 = 0x14
    base.fn0453e6()
}

/*
	MGZ 2 boss replacement
	just replaces it with Knuckles' boss. you can change this if you wish, but we can't guarantee it'll work.
*/

//# address-hook(0x06c31a) end(0x06c32c)
function void fn06c31a()
{
	if (MISC.player2.character == CHARACTER_TAILS)
	{
		base.fn06c31a()
		return
	}
	objA0.update_address = 0x06c698
}

//# address-hook(0x051842) end(0x0518f4)
function void InitLevelScrolling.MGZ2()
{
	base.InitLevelScrolling.MGZ2()
	if (MISC.player2.character != CHARACTER_TAILS)
		MISCPartner.setupMGZArena()
}

//# address-hook(0x0511c8) end(0x051278)
function void fn0511c8()
{
	base.fn0511c8()
	if (MISC.player2.character != CHARACTER_TAILS && global.zone_act == 0x0201) // act 2 gets loaded
		MISCPartner.setupMGZArena()
}

function void MISCPartner.setupMGZArena()
{
	u8[0xffff87fe] = 0x0d
	u8[0xffff877f] = 0x81
	u8[0xffff87ff] = 0x83
	u8[0xffff8780] = 0x45
	u8[0xffff8800] = 0x4a
	u8[0xffff8781] = 0x45
	u8[0xffff8801] = 0x4a
	u8[0xffff8782] = 0x45
	u8[0xffff8802] = 0x4a
	u8[0xffff8783] = 0x45
	u8[0xffff8803] = 0x4a
	u8[0xffff8784] = 0x7b
	u8[0xffff8804] = 0xb2
	u8[0xffff8806] = 0xc6
	u8[0xffff8807] = 0x01
}

//# address-hook(0x06c698) end(0x06c6ee)
function void fn06c698()
{
	if (MISC.player2.character == CHARACTER_TAILS)
	{
		base.fn06c698()
		return
	}
	// Use main boss music
	objA0.value26 = MUSIC_MAINBOSS
	StartBossFight()

	objA0.update_address = 0x06c6f4
	objA0.countdown_callback = 0x06c6fa

	Kosinski.addToDMAQueue(0x36b340, 0x67e0)		// Boss sprites

	Kosinski.addToDMAQueue(0x36d572, 0x8bc0)		// Falling debris sprites

	requestLoadingPatterns(0x6d)		// Robotnik's ship, boss explosions, and capsule sprites
	loadPaletteLine1(0x06d97c)

	level.bossarea.left -= getScreenExtend()
	level.bossarea.right += getScreenExtend()
}

//# address-hook(0x06c6f4) end(0x06c6f4)
function void fn06c6f4()
{
	base.fn06c6f4()
	if (MISC.player2.character == CHARACTER_TAILS)
		return
	if (objA0.countdown_value < 0)
		objA0.update_address = objA0.countdown_callback
}

//# address-hook(0x06c8b4) end(0x06c8ee)
function void fn06c8b4()
{
	if (MISC.player2.character == CHARACTER_TAILS)
	{
		base.fn06c8b4()
		return
	}
	objA0.update_address = 0x06c8f4
	level.wait_for_results = 0xff
	level.boss_encounter = 0

	if (allocDynamicObjectStd())
	{
		// Spawn capsule
		objA1.update_address = 0x086540
		objA1.position.x.u16 = 0x3ee8
		objA1.position.y.u16 = 0x730
	}

	screenmover_target.right = 0x3e48 + getScreenExtend()

	// "spawnSimpleChildObjects(0x084b00)" replaced by:
	spawnSimpleChildObjects(0x084a48, 1)		// Screen mover for the right border
}

//# address-hook(0x06c862) end(0x06c888)
function void fn06c862()
{
	base.fn06c862()
	if (MISC.player2.character == CHARACTER_TAILS)
		return
	objA0.position.y.u16 = 0x680
}

//# address-hook(0x06d4dc) end(0x06d512)
function void fn06d4dc()
{
	if (MISC.player2.character == CHARACTER_TAILS)
	{
		base.fn06d4dc()
		return
	}
	// Determine movement from the ground up
	GetRandomNumber()
	D0.u16 &= 0x7f
	D1.u16 = (D0.u16 & 0x01) + 4
	D2.u16 = u16[0xfffffa82] >> 1
	objA0.render_flags |= render_flag.FLIP_X
	D3.u8 = u8[0x06d516 + D2.u16]
	if (D3.u8 != 0)
	{
		D0.s16 = -D0.s16
		objA0.render_flags &= ~render_flag.FLIP_X
	}
	D1.u8 += D3.u8
	D3.u16 = 0x752

	// D0.s16 is a positional offset here, between -0x80 and 0x7f
	// D1.u16 determines how he moves:
	//  - 0x04 = Going straight up, looking right
	//  - 0x05 = Going diagonally from lower right to upper left, looking right
	//  - 0x06 = Going straight up, looking left
	//  - 0x07 = Going diagonally from lower left to upper right, looking left

	A2 = 0xfffffa8a
	fn06d45e()
}

//# translated(0x0117da) end(0x0118ba)
//# translated(0x015002) end(0x0150d8)
//# translated(0x017710) end(0x0177e8)
function bool Character.CheckStartJump()
{
	if objA0.update_address != addressof(Character.BaseUpdate.MISCPartner)
		return base.Character.CheckStartJump()
	
	u8 input_pressed_backup = (isMainCharacter(CHARACTER_TAILS)) ? control.player1.pressed : control.player1.pressed
	if MISC.getCharBase(MISC.player) == CHARACTER_TAILS
		control.tails.pressed = control.misc.pad2.pressed
	else
		control.player1.pressed = control.misc.pad2.pressed
	
	bool base = base.Character.CheckStartJump()
	
	if MISC.getCharBase(MISC.player) == CHARACTER_TAILS
		control.tails.pressed = input_pressed_backup
	else
		control.player1.pressed = input_pressed_backup
	return base
}

//# address-hook(0x01164e) end(0x0116dc)
//# address-hook(0x014e78) end(0x014f06)
//# address-hook(0x017680) end(0x01770e)
function void Character.UpdateControlInAir()
{
	if objA0.update_address != addressof(Character.BaseUpdate.MISCPartner)
	{
		base.Character.UpdateControlInAir()
		return
	}
	
	u8 input_backup = (isMainCharacter(CHARACTER_TAILS)) ? control.player1.state : control.player1.state
	if MISC.getCharBase(MISC.player) == CHARACTER_TAILS
		control.tails.state = control.misc.pad2.state
	else
		control.player1.state = control.misc.pad2.state
	base.Character.UpdateControlInAir()
	if MISC.getCharBase(MISC.player) == CHARACTER_TAILS
		control.tails.state = input_backup
	else
		control.player1.state = input_backup
}

function void Character.updateJumpMoves()
{
	if objA0.update_address != addressof(Character.BaseUpdate.MISCPartner)
	{
		base.Character.updateJumpMoves()
		return
	}

	
	u8 input_backup = (isMainCharacter(CHARACTER_TAILS)) ? control.player1.state : control.player1.state
	if MISC.getCharBase(MISC.player) == CHARACTER_TAILS
		control.tails.state = control.misc.pad2.state
	else
		control.player1.state = control.misc.pad2.state
	
	u8 input_pressed_backup = (isMainCharacter(CHARACTER_TAILS)) ? control.player1.pressed : control.player1.pressed
	if MISC.getCharBase(MISC.player) == CHARACTER_TAILS
		control.tails.pressed = control.misc.pad2.pressed
	else
		control.player1.pressed = control.misc.pad2.pressed
		
	base.Character.updateJumpMoves()
	
	if MISC.getCharBase(MISC.player) == CHARACTER_TAILS
		control.tails.state = input_backup
	else
		control.player1.state = input_backup
		
	if MISC.getCharBase(MISC.player) == CHARACTER_TAILS
		control.tails.pressed = input_pressed_backup
	else
		control.player1.pressed = input_pressed_backup
}

//# translated(0x011bde) end(0x011cf0)
//# translated(0x011d16) end(0x011da4)
//# translated(0x0151fc) end(0x01530c)
//# translated(0x015332) end(0x0153c0)
function bool Character.UpdateSpindash()
{
	if objA0.update_address != addressof(Character.BaseUpdate.MISCPartner)
	{
		return base.Character.UpdateSpindash()
	}

#if STANDALONE
	// Ignore this while charging the Super Peel-Out
	if (char.spindash == 0x80)
		return false
#endif

	u8 input_backup = (isMainCharacter(CHARACTER_TAILS)) ? control.player1.state : control.player1.state
	if MISC.getCharBase(MISC.player) == CHARACTER_TAILS
		control.tails.state = control.misc.pad2.state
	else
		control.player1.state = control.misc.pad2.state
	
	u8 input_pressed_backup = (isMainCharacter(CHARACTER_TAILS)) ? control.player1.pressed : control.player1.pressed
	if MISC.getCharBase(MISC.player) == CHARACTER_TAILS
		control.tails.pressed = control.misc.pad2.pressed
	else
		control.player1.pressed = control.misc.pad2.pressed
		
	bool base = base.Character.UpdateSpindash()
	
	if MISC.getCharBase(MISC.player) == CHARACTER_TAILS
		control.tails.state = input_backup
	else
		control.player1.state = input_backup
		
	if MISC.getCharBase(MISC.player) == CHARACTER_TAILS
		control.tails.pressed = input_pressed_backup
	else
		control.player1.pressed = input_pressed_backup
	return base
}

function void updateCharacterControlOnGround()
{
	if objA0.update_address != addressof(Character.BaseUpdate.MISCPartner)
	{
		base.updateCharacterControlOnGround()
		return
	}

	u8 input_backup = (isMainCharacter(CHARACTER_TAILS)) ? control.player1.state : control.player1.state
	if MISC.getCharBase(MISC.player) == CHARACTER_TAILS
		control.tails.state = control.misc.pad2.state
	else
		control.player1.state = control.misc.pad2.state
		
	base.updateCharacterControlOnGround()
	
	if MISC.getCharBase(MISC.player) == CHARACTER_TAILS
		control.tails.state = input_backup
	else
		control.player1.state = input_backup
}

function void Character.updateUprightOnGroundInner()
{
	if objA0.update_address != addressof(Character.BaseUpdate.MISCPartner)
	{
		base.Character.updateUprightOnGroundInner()
		return
	}

	u8 input_backup = (isMainCharacter(CHARACTER_TAILS)) ? control.player1.state : control.player1.state
	if MISC.getCharBase(MISC.player) == CHARACTER_TAILS
		control.tails.state = control.misc.pad2.state
	else
		control.player1.state = control.misc.pad2.state
		
	base.Character.updateUprightOnGroundInner()
	
	if MISC.getCharBase(MISC.player) == CHARACTER_TAILS
		control.tails.state = input_backup
	else
		control.player1.state = input_backup
}

//# address-hook(0x01174a) end(0x0117d8)
//# address-hook(0x014f74) end(0x015000)
function void Character.CheckForStartRolling()
{
	if objA0.update_address != addressof(Character.BaseUpdate.MISCPartner)
	{
		base.Character.CheckForStartRolling()
		return
	}

	u8 input_backup = (isMainCharacter(CHARACTER_TAILS)) ? control.player1.state : control.player1.state
	if MISC.getCharBase(MISC.player) == CHARACTER_TAILS
		control.tails.state = control.misc.pad2.state
	else
		control.player1.state = control.misc.pad2.state
		
	base.Character.CheckForStartRolling()
	
	if MISC.getCharBase(MISC.player) == CHARACTER_TAILS
		control.tails.state = input_backup
	else
		control.player1.state = input_backup
}

function bool isSonicIntro()
{
	if (global.characters == CHARACTER_REIMU)
		return false
	return base.isSonicIntro()
}

//# address-hook(0x01c46e) end(0x01c4ce)
function void fn01c46e()
{
    if !(global.characters == CHARACTER_REIMU)
    {
        base.fn01c46e()
        return
    }
    
	u8 checkpoint = checkpoint.number
	checkpoint.number = 1
	base.fn01c46e()
	checkpoint.number = checkpoint
}

//# address-hook(0x01c4d0) end(0x01c54e)
function void fn01c4d0()
{
    if !(global.characters == CHARACTER_REIMU)
    {
        base.fn01c4d0()
        return
    }
    
	u8 checkpoint = checkpoint.number
	checkpoint.number = 1
	base.fn01c4d0()
	checkpoint.number = checkpoint
}

//finally replace AI with different one, because tails & tails.

define control.misc.pad2 = u16[0xfffff66c]
define control.misc.pad2.state = u8[0xfffff66c]
define control.misc.pad2.pressed = u8[0xfffff66d]

//# address-hook(0x0010de) end(0x001118)
function void UpdateControllers()
{
    control.misc.pad2.state = Input.getController(1)
    control.misc.pad2.pressed = control.misc.pad2.state & ~Input.getControllerPrevious(1)
    base.UpdateControllers()
}

//# address-hook(0x013d4a) end(0x013ec8)
function void fn013d4a()
{   
	if objA0.update_address != addressof(Character.BaseUpdate.MISCPartner)
	{
		base.fn013d4a()
		return
	}

    if (u8[0xffffb000 + 0x05] >= base_state.DIED)
	{
		tails.ai_routine = 0x04
		char.spindash = 0
		char.spindash_charge = 0
		char.control_flags = (control_flag.DISABLE_INTERACTION | control_flag.DISABLE_UPDATE)
		char.flags = char.flag.IN_AIR
		char.state = char.state.TAILS_FLYDOWN
		return
	}

	fn013efc()

	if (tails.control_counter == 0 && (u8[A0 + 0x2e] & 0x80) == 0 && (u8[A1 + 0x37] & 0x80) == 0)
	{
		if (char.hlock_countdown != 0 && char.groundspeed == 0)
		{
			tails.ai_routine = 0x08
		}

		D0.u8 = posbackup.offset.player1 - 0x44
		u16 targetPosX = u16[0xffffe500 + D0.u8]
		u16 targetPosY = u16[0xffffe500 + D0.u8 + 2]
		u16 controlBackup = u16[0xffffe400 + D0.u8]
		u8 flagsBackup = u8[0xffffe400 + D0.u8 + 2]
	#if STANDALONE
		// Make Tails account for Sonic's speed just enough he won't fall behind in AIZ 2 bombing section
		targetPosX += (objA1.velocity.x >> 7)
	#endif

		if ((objA1.flags2a & char.flag.ON_OBJECT) == 0 && objA1.groundspeed < 0x400)
		{
			// Prefer to stand left, not directly behind main character
			targetPosX -= 0x20
		}
		s16 relativeTargetPosX = targetPosX - char.position.x.u16

		control.misc.pad2 = controlBackup
		if ((char.flags & char.flag.PUSHING) && ((flagsBackup & char.flag.PUSHING) == 0))
		{
			// Jump over obstacle
		#if STANDALONE
			// Do not jump if target position is close anyways
			if (abs(relativeTargetPosX) >= 0x30)
		#endif
			if ((level.framecounter.low & 0x3f) == 0 && char.state != char.state.COWERING)
			{
				control.misc.pad2 |= 0x7070		// CONTROL_ABC, CONTROL_ABC
				tails.ai_jumping = 1
			}
		}
		else
		{
			if (relativeTargetPosX == 0)
			{
				char.flags = (char.flags & ~char.flag.FACING_LEFT) | (flagsBackup & char.flag.FACING_LEFT)
			}
			else
			{
				if (relativeTargetPosX < 0)
				{
					if (relativeTargetPosX <= -0x30)
					{
						control.misc.pad2 = (control.misc.pad2 & ~0x0c0c) | 0x0404		// Move left
					}

					if (char.groundspeed != 0 && (char.flags & char.flag.FACING_LEFT) != 0 && (char.control_flags & 0x01) == 0)
					{
						--char.position.x.u16
					}
				}
				else
				{
					if (relativeTargetPosX >= 0x30)
					{
						control.misc.pad2 = (control.misc.pad2 & ~0x0c0c) | 0x0808		// Move right
					}

					if (char.groundspeed != 0 && (char.flags & char.flag.FACING_LEFT) == 0 && (char.control_flags & 0x01) == 0)
					{
						++char.position.x.u16
					}
				}
			}

			if (tails.ai_jumping != 0)
			{
				control.misc.pad2 |= 0x7000		// CONTROL_ABC, 0
				if (char.flags & char.flag.IN_AIR)
					return

				tails.ai_jumping = 0
			}

			if ((level.framecounter & 0xff) == 0 || abs(relativeTargetPosX) < 0x40)
			{
				s16 relativeTargetPosY = targetPosY - char.position.y.u16
				if (relativeTargetPosY <= -0x20)
				{
					if (((level.framecounter.low & 0x3f) == 0) && (char.state != char.state.COWERING))
					{
						control.misc.pad2 |= 0x7070		// CONTROL_ABC, CONTROL_ABC
						tails.ai_jumping = 1
					}
				}
			}

		#if STANDALONE
			// If both are standing still horizontally... (which includes spindash charging)
			if (char.velocity.x == 0 && objA1.velocity.x == 0)
			{
				// Make sure Tails looks into the same direction as the main player
				if ((objA0.flags2a & char.flag.FACING_LEFT) != (objA1.flags2a & char.flag.FACING_LEFT))
				{
					objA0.flags2a = (objA0.flags2a & ~char.flag.FACING_LEFT) | (objA1.flags2a & char.flag.FACING_LEFT)
				}

				// Start charging a spindash if the main player does so as well
				if (char.spindash == 0 && u8[A1 + 0x3d] != 0 && char.state == char.state.COWERING)
				{
					control.misc.pad2 |= 0x0020		// 0, CONTROL_C
				}
			}
		#endif
		}
	}
	else if (tails.control_counter != 0)
	{
		--tails.control_counter
	}
}

//# address-hook(0x0139cc) end(0x0139e8)
function void Character.TailsAI.Update()
{

	if objA0.update_address != addressof(Character.BaseUpdate.MISCPartner)
	{
		base.Character.TailsAI.Update()
		return
	}

	A1 = 0xffffb000		// Player 1

	// When player 2 presses any key, that disables the AI for 10 seconds
	if (control.misc.pad2.state & ~CONTROL_START)
	{
		tails.control_counter = 600		// 10 sec
	}
	
	#if STANDALONE
	if (MODIFICATION_TOGETHERNESS)
	{
		if (Input.buttonPressed(BUTTON_PAD2 | BUTTON_Y) && tails.ai_routine == 0x06 && tails.ai_routine <= 0x06)
		{
			// Reset Tails next to Player 1
			u32 positionLookupAddress = 0xffffe500 + u32(u8(posbackup.offset.player1 - 20))

			char.render_flags = (char.render_flags & ~(render_flag.FLIP_X | render_flag.FLIP_Y)) | (objA1.render_flags & (render_flag.FLIP_X | render_flag.FLIP_Y))
			char.position.x.u16 = u16[positionLookupAddress]
			char.position.y.u16 = u16[positionLookupAddress + 2]
			char.velocity.x = objA1.velocity.x
			char.velocity.y = objA1.velocity.y
			char.groundspeed = objA1.groundspeed
			char.state = objA1.state
			char.rotation = u8[A1 + 0x26]
			char.rotation.x = u8[A1 + 0x27]
			char.flags = (char.flags & ~0x03) | (objA1.flags2a & 0x03)
			char.control_flags = u8[A1 + 0x2e]
			char.layer_flags1 = u8[A1 + 0x46]
			char.layer_flags2 = u8[A1 + 0x47]

			tails.ai_routine = 0x06
			tails.control_counter = 600		// 10 sec
		}
	}

	// This should only be called if SETTING_TAILS_ASSIST_MODE is active
	if (tails.ai_routine == 0x30)
	{
		if (updateTailsAssist())
			return

		// Return to usual behavior
		tails.ai_routine = 0x06
	}
#endif

	// Targets:
	//  - 0x013a10	-> tails.ai_routine = 0x00	-> Initialization (single frame)
	//  - 0x013b26	-> tails.ai_routine = 0x02	-> Respawn (can be a single frame)
	//  - 0x013bf8	-> tails.ai_routine = 0x04	-> Flying in
	//  - 0x013d4a	-> tails.ai_routine = 0x06	-> Normal state, controlled by player or AI
	//  - 0x013f40	-> tails.ai_routine = 0x08	-> Automatically spindashing up slopes
	//  - 0x013fc0	-> tails.ai_routine = 0x0a	-> Inactive (e.g. in AIZ Intro with Sonic & Tails, but not with Sonic alone)
	//  - 0x013fc2	-> tails.ai_routine = 0x0c	-> Flying Sonic in automatically, Initialization
	//  - 0x013ffa	-> tails.ai_routine = 0x0e	-> Flying Sonic in automatically (e.g. CNZ 1 start with Sonic & Tails)
	//  - 0x01408a	-> tails.ai_routine = 0x10	-> Flying away to disappear      (e.g. CNZ 1 start with Sonic alone)
	//  - 0x0140c6	-> tails.ai_routine = 0x12	-> Direct control in MGZ 2 boss, waiting (direct control by first player, used in MGZ 2 boss with Sonic)
	//  - 0x0140ce	-> tails.ai_routine = 0x14	-> Direct control in MGZ 2 boss, initialization
	//  - 0x014106	-> tails.ai_routine = 0x16	-> Direct control in MGZ 2 boss, entering the screen from below
	//  - 0x01414c	-> tails.ai_routine = 0x18	-> Direct control in MGZ 2 boss, now actually controllable
	//  - 0x0141f2	-> tails.ai_routine = 0x1a	-> In MGZ 2 boss alone, initialization
	//  - 0x01421c	-> tails.ai_routine = 0x1c	-> In MGZ 2 boss alone, entering the screen from below
	//  - 0x014254	-> tails.ai_routine = 0x1e	-> In MGZ 2 boss alone, sets flight countdown to regain control
	//  - 0x01425c	-> tails.ai_routine = 0x20	-> Flying in automatically alone, Initialization
	//  - 0x014286	-> tails.ai_routine = 0x22	-> Flying in automatically alone (e.g. CNZ 1 start with Tails alone)
	call tableLookupAddress(0x0139ec, tails.ai_routine)
}

//Make tails' tails work for 4 players
constant u32 tailstails.p1 = 0xffffcc0a
constant u32 tailstails.p2 = 0xffffc35e
constant u32 tailstails.p3 = 0xffffc3a8
constant u32 tailstails.p4 = 0xffffc3f2