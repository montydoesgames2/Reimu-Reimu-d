
#define MISC_SPECIALPLAYERS_ADDON

function void MISC.SpawnSpecialPlayer()
{
	if global.characters == CHARACTER_REIMU //prevent looping by putting if statement here
	{
		
		return
	}
	
	base.MISC.SpawnSpecialPlayer()
}

function bool MISC.SpawnSpecialPlayer2()
{
	MISC.player2.character = 0

	if global.characters == CHARACTER_REIMU && (global.zone >= 0x0a) && (global.zone <= 0x0c)
	{
		u32[0xffffb04a] = addressof(Character.BaseUpdate.MISCPartner)
		u16[0xffffb04a + 0x10] = u16[0xffffb000 + 0x10] - 0x20
		u16[0xffffb04a + 0x14] = u16[0xffffb000 + 0x14] + 4
		u32[0xffffcc9e] = 0x018b3e
		tails.ai_routine = 0
		//set player 2 as partner
		MISC.setPlayer(2, CHARACTER_SONIC) //this can literally be any MISC character, even the same as player 1.
		return true
	}
	
	return base.MISC.SpawnSpecialPlayer2()
}

function void MISC.setPlayer(u8 player, u8 character)
{
	u32 A0backup = A0
	//tag team support
	A0 = (player == 1) ? 0xffffb000 : (player == 2) ? 0xffffb04a : (player == 3) ? 0xffffc2ca : 0xffffc314
	
	MISC.player = character
	if player == 2
		MISC.player2.character = character
	A0 = A0backup
}

//Check if A0 is the selected player
function bool MISC.isPlayer(u8 player)
{
	//tag team compat
	u8 check = (A0 == 0xffffb000) ? 1 : (A0 == 0xffffb04a) ? 2 : (A0 == 0xffffc2ca) ? 3 : 4
	
	if check == player
		return true
	return false
}

//get the current player in a certain player slot DURING STAGES
function bool MISC.getCharacter(u8 player, u8 character)
{
	if character < 4 //not a MISC char
	{
		u32 A0backup = A0
		//tag team support
		A0 = (player == 1) ? 0xffffb000 : (player == 2) ? 0xffffb04a : (player == 3) ? 0xffffc2ca : 0xffffc314
		
		if char.character == character
			return true
			
		A0 = A0backup
	}

	if player == 1
	{
		if global.characters == character
			return true
	}
	else
	{
		u32 A0backup = A0
		//tag team support
		A0 = (player == 2) ? 0xffffb04a : (player == 3) ? 0xffffc2ca : 0xffffc314
		
		if MISC.player == character
			return true
		
		A0 = A0backup
	}
	
	return false
}

//Checks if current player at selected address is the character
function bool MISC.isCharacter(u32 address, u8 character)
{
	u32 A0backup = A0
	A0 = address

	if character < 4 //not a MISC char
	{
		if char.character == character
		{
			A0 = A0backup
			return true
		}
	}

	if A0 == 0xffffb000
	{
		if global.characters == character
		{
			A0 = A0backup
			return true
		}
	}
	else
	{
		if MISC.player == character
		{
			A0 = A0backup
			return true
		}
	}
	
	A0 = A0backup
	
	return false
}

define MISC.player = u8[A0 + 0x29]

//# address-hook(0x1f0a94)
function void Character.BaseUpdate.MISCPartner()
{
	//correct spindash stuff in post
	u8 SpindashOffset = (getSecondCharacter() != CHARACTER_TAILS) ? 0 : 1
	if u8[0xffffcc9e + 0x38] != SpindashOffset
		u8[0xffffcc9e + 0x38] = SpindashOffset
		
	A4 = addressof(global.move.speedcap.tails)	// Address: 0xfffff760 = Base address of speed caps & acceleration/deceleration
	A5 = addressof(camera.yoffset.tails)	// Address: 0xffffee2c
	A6 = 0xffffcc9e							// Base address of dust cloud object
	
	if MISC.getCharBase(MISC.player2.character) == CHARACTER_SONIC
	{
		if char.character != CHARACTER_SONIC
			char.base_state = 0

		// Targets:
		//	- 0x010afa	-> char.base_state = 0x00 = base_state.INITIAL	-> Character.Initialization.Sonic()		-> Initialization
		//	- 0x010bba	-> char.base_state = 0x02 = base_state.NORMAL	-> Character.UpdateNormalState.Sonic()	-> In normal state
		//	- 0x0122be	-> char.base_state = 0x04 = base_state.HURT		-> Character.UpdateGotHurtState.Sonic()	-> Sonic just got hurt
		//	- 0x012390	-> char.base_state = 0x06 = base_state.DIED		-> Character.UpdateDiedState.Sonic()	-> Sonic died
		//	- 0x01257c	-> char.base_state = 0x08 = base_state.INACTIVE	-> Character.UpdateRestartDelay()		-> Completely inactive after death
		//	- 0x0125ac	-> char.base_state = 0x0c = base_state.DROWNED	-> Character.UpdateDrownedState.Sonic()	-> Sonic died by drowning
		
		if char.base_state == 0x02
		{
			// Tails is the second player
			if (player2.control_override == 0)
			{
				control.tails = control.pad2
			}

			if (player2.control_override >= 0 && competition_mode.active == 0)
			{
				Character.TailsAI.Update()
			}
		}
		
		call tableLookupAddress(0x010aec, char.base_state)
	}
	else if MISC.getCharBase(MISC.player2.character) == CHARACTER_KNUCKLES
	{
		if char.character != CHARACTER_KNUCKLES
			char.base_state = 0

		// Targets:
		//  - 0x0164aa	-> char.base_state = 0x00 = base_state.INITIAL	-> Character.Initialization.Knuckles()		-> Initialization
		//  - 0x01656c	-> char.base_state = 0x02 = base_state.NORMAL	-> Character.UpdateNormalState.Knuckles()	-> In normal state
		//  - 0x017bb6	-> char.base_state = 0x04 = base_state.HURT		-> Character.UpdateGotHurtState.Knuckles()	-> Knuckles just got hurt
		//  - 0x017c88	-> char.base_state = 0x06 = base_state.DIED		-> Character.UpdateDiedState.Knuckles()		-> Knuckles died
		//  - 0x017cba	-> char.base_state = 0x08 = base_state.INACTIVE	-> Character.UpdateRestartDelay()			-> Completely inactive after death
		//  - 0x017cea	-> char.base_state = 0x0c = base_state.DROWNED	-> Character.UpdateDrownedState.Knuckles()	-> Knuckles died by drowning
		
		if char.base_state == 0x02
		{
			// Tails is the second player
			if (player2.control_override == 0)
			{
				control.tails = control.pad2
			}

			if (player2.control_override >= 0 && competition_mode.active == 0)
			{
				Character.TailsAI.Update()
			}
		}
		
		call tableLookupAddress(0x01649c, char.base_state)
	}
	else
	{
		if char.character != CHARACTER_TAILS
			char.base_state = 0
	
		// Check for debug mode
		if (debug_mode.state == 0 || !isMainCharacter(CHARACTER_TAILS))	// Maybe a check if it's second player Tails?
		{
			// Targets:
			//  - 0x0136ca	-> char.base_state = 0x00 = base_state.INITIAL	-> Character.Initialization.Tails()		-> Initialization
			//  - 0x0137c4	-> char.base_state = 0x02 = base_state.NORMAL	-> Character.UpdateNormalState.Tails()	-> In normal state
			//  - 0x01569c	-> char.base_state = 0x04 = base_state.HURT		-> Character.UpdateGotHurtState.Tails()	-> Tails just got hurt
			//  - 0x01578e	-> char.base_state = 0x06 = base_state.DIED		-> Character.UpdateDiedState.Tails()	-> Tails died
			//  - 0x0157e0	-> char.base_state = 0x08 = base_state.INACTIVE	-> Character.UpdateRestartDelay()		-> Completely inactive after death
			//  - 0x015810	-> char.base_state = 0x0c = base_state.DROWNED	-> Character.UpdateDrownedState.Tails()	-> Tails died by drowning
			call tableLookupAddress(0x0136bc, char.base_state)
		}
		else if (updateDebugModeRegular())
		{
			UpdateTailsSpritePatterns()
			DrawObject()
		}
	}
	
	//force a respawn a certain distance away from player 1
	
	u32 A1backup = A1
	A1 = 0xffffb000
	//MATH TIME
	float d = Math.sqrt(Math.sqr(abs((objA1.position.x.u16 - objA0.position.x.u16))) + Math.sqr(abs((objA1.position.y.u16 - objA0.position.y.u16))))
	A1 = A1backup
	
	if d > 2000.0 && player2.control_override == 0 && global.level_started && char.control_flags == 0
	{
		// Second player Tails
		char.base_state = base_state.NORMAL
		RespawnTails()
	}
}

function void updateCharacterSpritePatterns(u8 character, u8 animationSprite)
{
	if objA0.update_address != addressof(Character.BaseUpdate.MISCPartner)
	{
		base.updateCharacterSpritePatterns(character, animationSprite)
		return
	}
}

function bool Standalone.onWriteToSpriteTable(s16 px, s16 py, u16 renderQueue)
{
	bool prioFlag = (objA0.sprite_attributes & sprite_attribute.PRIORITY) != 0
	
	// Characters in special stage
	if (objA0.update_address == 0x00927a) && MISC.player2.character == CHARACTER_SONIC && global.characters == CHARACTER_REIMU
	{
		//This just uses the base MISC character's sprite key.
	
		u8 character = (objA0.update_address == 0x00927a) ? MISC.player2.character : MISC.player1.character
		u8 atex = (character == CHARACTER_TAILS) ? 0x10 : 0x00
		u64 key = stringformat(stringformat("%s_0x%02x", getCharacterBluesphereSpriteKey(character)), objA0.animation.sprite)
		if (Renderer.hasCustomSprite(key))
		{
			// Check if there's also a custom palette
			string paletteKey = getCharacterBluespherePaletteKey(character)
			if (System.hasExternalPaletteData(paletteKey, 0))
			{
				atex = 0x40 + character * 0x20
			}
		}
		else //FAILSAFE, use base characters' sprites.
		{
			character = getSecondCharacter()
			atex = (character == CHARACTER_TAILS) ? 0x10 : 0x00
			if (character == CHARACTER_SONIC)
				key = Renderer.setupCustomCharacterSprite(0x0aaa7c, 0x0abe14, 0x000abdfc, objA0.animation.sprite, atex)
			else if (character == CHARACTER_TAILS)
				key = Renderer.setupCustomCharacterSprite(0x28f95a, 0x2908d2, objA0.mapping_offset, objA0.animation.sprite, atex)
			else
				key = Renderer.setupCustomCharacterSprite(0x0abf22, 0x0ad31a, 0x0ad302, objA0.animation.sprite, atex)

			if (ROMDataAnalyser.isEnabled())
				Renderer.extractCustomSprite(key, getCharacterBluesphereSpriteKey(character), objA0.animation.sprite, atex)
		}
		Renderer.drawCustomSprite(key, px, py, atex, prioFlag ? SPRITE_FLAG_PRIO : 0, renderQueue)
		return true
	}
	
	// Tails' tails object in special stage
	if (objA0.update_address == 0x009488) && MISC.player2.character == CHARACTER_SONIC && global.characters == CHARACTER_REIMU
	{
		//Either change it or just do nothing and just return true. if your character HAS tails' tails for... some reason?? you can just remove this.
		return true
	}
	
	return base.Standalone.onWriteToSpriteTable(px, py, renderQueue)
}

//Draw the 2nd player and their tails.
function bool Standalone.drawCharacterSprite(u8 character, u8 variant, s16 px, s16 py, bool asSmallGhost)
{
	if global.characters < 4 && !(A0 == 0xffffb04a || A0 == 0xffffcc0a)
		return base.Standalone.drawCharacterSprite(character, variant, px, py, asSmallGhost)

	if (A0 == 0xffffb04a || A0 == 0xffffcc0a)
		return MISC.drawCharacterSprite(character, MISC.player2.character, variant, px, py, asSmallGhost)
		
	return base.Standalone.drawCharacterSprite(character, variant, px, py, asSmallGhost)
}

//Don't allow partner super transformations
function bool Character.performSuperTransformation()
{
	//Log = A0
	if objA0.update_address != addressof(Character.BaseUpdate.MISCPartner)
		return base.Character.performSuperTransformation()
}

//Don't allow partners to cancel super transformation
function void Character.cancelSuperTransformation()
{
	if objA0.update_address != addressof(Character.BaseUpdate.MISCPartner)
		base.Character.cancelSuperTransformation()
}

//spawn the character
function void Character.Initialization.shared(u8 character)
{
	base.Character.Initialization.shared(character)
	
	if objA0.update_address != addressof(Character.BaseUpdate.MISCPartner)
		return

	if (isMainCharacter(CHARACTER_TAILS) || isMainCharacter(CHARACTER_KNUCKLES)) //fix the layers
	{
		if (checkpoint.number == 0)
		{
			char.sprite_attributes = (Char.Tails.targetInVRAM >> 5)
			char.layer_flags1 = 0x0c
			char.layer_flags2 = 0x0d

			if (global.stage_type != 2)
			{
				checkpoint.x = char.position.x.u16
				checkpoint.y = char.position.y.u16
				checkpoint.sprite_attr = char.sprite_attributes
				checkpoint.layer_flags = char.layer_flags
			}
		}
	}
	else
	{
		char.sprite_attributes = (Char.Tails.targetInVRAM >> 5) | (u16[0xffffb000 + 0x0a] & sprite_attribute.PRIORITY)
		char.layer_flags = u16[0xffffb000 + 0x46]
	}

	super.active.tails = 0

	if (tails.ai_routine != 0x12 && tails.ai_routine != 0x20)
		tails.ai_routine = 0

	tails.control_counter = 0
	tails.respawn_counter = 0

	//choose whether or not to keep tails' tails.
	if (character == CHARACTER_TAILS)
	{
		// Init Tails' tails object
		u32[0xffffcc0a] = addressof(TailsTails.Init)
		u16[0xffffcc0a + 0x30] = A0.u16	
	}
	else
	{
		// Delete Tails' tails object
		u32[0xffffcc0a] = 0
	}
	
	checkpoint.number.backup.tails = checkpoint.number
}

function bool onCharacterPressedJumpInMidAir(u8 input_state, u8 input_pressed)
{
	u32 A0backup = A0
	A0 = 0xffffb04a
	if objA0.update_address != addressof(Character.BaseUpdate.MISCPartner) //only do tails assist if the player IS tails.
	{
		A0 = A0backup
		return base.onCharacterPressedJumpInMidAir(input_state, input_pressed)
	}
	A0 = A0backup
	
	//you can put unique interactions here
	
	//don't allow normal double jump moves
	if objA0.update_address == addressof(Character.BaseUpdate.MISCPartner)
		return false

	// Use normal jump button reaction
	return true
}

//Change how the AI for partners is initialised
//# address-hook(0x013a10) end(0x013b24)
function void Character.TailsAI.Init()
{
    if (checkpoint.number.backup.tails == 0) && objA0.update_address == addressof(Character.BaseUpdate.MISCPartner)   // This is some checkpoint number backup for Tails
    {
        bool isKnucklesIntro = (Game.getSetting(SETTING_AIZ_INTRO_KNUCKLES) != 0 && isMainCharacter(CHARACTER_KNUCKLES) && checkpoint.number == 0 && !Game.isTimeAttack())
        if (global.zone_act == 0x0000 && !isSonicIntro() && !isKnucklesIntro)        // AIZ 1
        {
            char.state = char.state.RUNNING
            char.velocity.x = 0
            char.velocity.y = 0
            char.groundspeed = 0
            char.flags = 0
            char.control_flags = 0
            tails.respawn_counter = 0
            tails.ai_routine = 0x06
            return
        }
		else if ((global.zone_act == 0x0300) || (global.zone_act == 0x0700 && global.lock_on_state == 0)) && !SpawnAITails(global.characters)		// CNZ 1
		{
			char.state = (global.zone_act == 0x0700) ? char.state.GOT_HURT_PANIC : char.state.RUNNING
			char.velocity.x = 0
			char.velocity.y = 0
			char.groundspeed = 0
			char.flags = (global.zone_act == 0x0700) ? char.flag.IN_AIR : 0
			char.control_flags = 0
			tails.respawn_counter = 0
			tails.ai_routine = 0x06
			return
		}
    }

    base.Character.TailsAI.Init()
}

//Ignore player 1's CheckStartJump interactions
//# translated(0x0117da) end(0x0118ba)
//# translated(0x015002) end(0x0150d8)
//# translated(0x017710) end(0x0177e8)
function bool Character.CheckStartJump()
{
	if objA0.update_address != addressof(Character.BaseUpdate.MISCPartner)
		return base.Character.CheckStartJump()
	
	u8 input_pressed = control.tails.pressed
	if ((input_pressed & CONTROL_ABC) == 0)
		return false

	D0 = char.rotation
	if (global.inv_gravity)
	{
		D0.s8 = -D0.s8
	}
	else
	{
		D0.s8 += 0x80
	}

	pushA456()
	fn00f72e()
	popA456()

	if (D1.s16 < 6)
		return false

	// Get jump acceleration depending on character
	u16 acceleration
	if (char.character != CHARACTER_KNUCKLES || competition_mode.active)
	{
		if (char.flags & char.flag.UNDERWATER)
		{
			acceleration = 0x380
		}
		else if (super.active && char.character == CHARACTER_SONIC)
		{
			acceleration = 0x800
		}
		else
		{
			acceleration = 0x680
		}
	}
	else
	{
		if (char.flags & char.flag.UNDERWATER)
		{
			acceleration = 0x300
		}
		else
		{
			acceleration = 0x600
		}
	}

	u8 angle = char.rotation - 0x40
	s32 accel_x = (s32(lookupCos(angle)) * acceleration) >> 8
	s32 accel_y = (s32(lookupSin(angle)) * acceleration) >> 8

	char.velocity.x += accel_x
	char.velocity.y += accel_y

	char.flags |= char.flag.IN_AIR
	char.flags &= ~char.flag.PUSHING

	char.jumping = 1
	char.on_convex_surface = 0

	playSound(SFX_JUMP)

	// Start roll jump
	if (char.flags & char.flag.ROLLING)
	{
	#if STANDALONE
		if (!Game.getSetting(SETTING_NO_CONTROL_LOCK))
	#endif
		{
			char.hitbox_extends.x = char.hitbox.default.x
			char.hitbox_extends.y = char.hitbox.default.y
			char.flags |= char.flag.CONTROL_LOCK
		}
	}
	else
	{
		char.hitbox_extends.x = char.hitbox.x.ROLLING
		char.hitbox_extends.y = char.hitbox.y.ROLLING
		char.flags |= char.flag.ROLLING
		char.state = char.state.ROLLING

		s8 dy = s8(char.hitbox_extends.y) - s8(char.hitbox.default.y)
		char.position.y.u16 += global.inv_gravity ? dy : -dy

	#if STANDALONE
		// Glitch fix for Knuckles being unable to jump off underwater objects
		//  -> Move him up a single pixel up so he won't stick to objects
		// TODO: Does not work for the HCZ snake platforms
		if (acceleration <= 0x300 && (char.flags & char.flag.ON_OBJECT))
		{
			--char.position.y.u16
		}
	#endif
	}
	return true
}

//Respawn the partner
//# address-hook(0x013bf8) end(0x013d48)
function void fn013bf8()
{
	if u32[0xffffb04a] != addressof(Character.BaseUpdate.MISCPartner)
	{
		base.fn013bf8()
		return
	}
	
	char.rotation = 0
	
	//These are the interactions for each character when they respawn.
	//Tails flies down, sonic just falls, and knuckles glides down.
	//You can change these, since it's pretty much all that matters
	if (objA0.render_flags & render_flag.VISIBLE)
	{
		if char.character == CHARACTER_SONIC
		{
			UpdateMovementStraight()
			char.velocity.y += 0x38
			char.flags |= char.flag.IN_AIR
			char.state = char.state.ROLLING
		}
		else if char.character == CHARACTER_TAILS
		{
			tails.flight_countdown = 0xf0
			char.flags |= char.flag.IN_AIR
			UpdateTailsFlight_innerB()
			tails.respawn_counter = 0
		}
		else
		{
			UpdateKnucklesGlide()
		}
		
		char.sprite_priority = objA1.sprite_priority
		char.control_flags &= ~(control_flag.DISABLE_ANIMATION | control_flag.DISABLE_UPDATE)
		char.control_flags |= control_flag.DISABLE_WALLS
	}
	
	D3.u8 = posbackup.offset.player1 - 0x44
	tails.flight_target.x = u16[0xffffe500 + D3.u8]
	tails.flight_target.y = u16[0xffffe500 + D3.u8 + 2]

	s16 dx = char.position.x.u16 - tails.flight_target.x
	if (dx != 0)
	{
		s16 moveX = min(abs(dx) >> 4, 12)
		moveX += abs(objA1.velocity.x) + 1
		if (dx >= 0)
		{
			char.flags |= char.flag.FACING_LEFT
			if (moveX >= dx)
			{
				moveX = dx
				dx = 0
			}
			char.position.x.u16 -= moveX
		}
		else
		{
			char.flags &= ~char.flag.FACING_LEFT
			dx = -dx
			if (moveX >= dx)
			{
				moveX = dx
				dx = 0
			}
			char.position.x.u16 += moveX
		}
	}

	s16 dy = char.position.y.u16 - tails.flight_target.y
	if (dy != 0)
	{
	#if STANDALONE
		// Consider vertical level wrap
		if (level.vertical_wrap == 0xff00)
		{
			dy &= level.height.bitmask
			if (dy > level.height.bitmask / 2)
				dy -= (level.height.bitmask + 1)
		}
	#endif
		char.position.y.u16 += (dy > 0) ? -1 : 1
	}

	D2.u8 = u8[0xffffe400 + D3.u8 + 2] & 0x80
	if (D2.u8 == 0 && u8[0xffffb000 + 0x05] < base_state.DIED)
	{
	#if STANDALONE
		// Let Tails drop down when close enough to either the target point or the main character's current position
		bool gainControlNow = (char.character != CHARACTER_SONIC) ? (abs(dx) <= 4 && abs(dy) <= 4) : abs(dy) <= 4
		gainControlNow = gainControlNow || (abs(objA1.position.x.u16 - char.position.x.u16) <= 4 && abs(objA1.position.y.u16 - char.position.y.u16) <= 4)

		// Allow for pressing a jump button to gain control over Tails at once
		gainControlNow = gainControlNow || (control.tails.pressed & CONTROL_ABC)
	#else
		bool gainControlNow = (dx == 0 && dy == 0)
	#endif

		if (gainControlNow)
		{
			if char.character != CHARACTER_SONIC
			{
				char.velocity.x = 0
				char.velocity.y = 0
			}
		
			tails.ai_routine = 0x06
			char.control_flags = 0
			char.state = char.state.RUNNING
			char.groundspeed = objA1.groundspeed
			char.flags &= char.flag.UNDERWATER
			char.flags |= char.flag.IN_AIR
			char.hlock_countdown = 0
			char.sprite_attributes = (char.sprite_attributes & ~sprite_attribute.PRIORITY) | (objA1.sprite_attributes & sprite_attribute.PRIORITY)
			char.layer_flags1 = u8[A1 + 0x46]
			char.layer_flags2 = u8[A1 + 0x47]

			if (gainControlNow)
			{
				// Roll instead
				char.state = char.state.ROLLING
			}
			return
		}
	}
	char.control_flags = (control_flag.DISABLE_INTERACTION | control_flag.DISABLE_UPDATE)
}

//p2's air control
//# address-hook(0x01164e) end(0x0116dc)
//# address-hook(0x014e78) end(0x014f06)
//# address-hook(0x017680) end(0x01770e)
function void Character.UpdateControlInAir()
{
	if objA0.update_address != addressof(Character.BaseUpdate.MISCPartner)
	{
		base.Character.UpdateControlInAir()
		return
	}
	
	u8 input_state = control.tails.state
	s16 vx = char.velocity.x

	// Direct control
	if ((char.flags & char.flag.CONTROL_LOCK) == 0)
	{
		s16 maxSpeed = s16[A4]
		s16 acceleration = s16[A4 + 2] * 2

		if (input_state & CONTROL_LEFT)
		{
			char.flags |= char.flag.FACING_LEFT
			vx -= acceleration
			if (vx <= -maxSpeed)
			{
				vx += acceleration
				vx = min(vx, -maxSpeed)
			}
		}
		if (input_state & CONTROL_RIGHT)
		{
			char.flags &= ~char.flag.FACING_LEFT
			vx += acceleration
			if (vx >= maxSpeed)
			{
				vx -= acceleration
				vx = max(vx, maxSpeed)
			}
		}
	}

	// Center camera y-offset again
	centerCameraYOffset()

	// Air drag
	if (char.velocity.y < 0 && char.velocity.y >= -0x400)  // Not when falling or going up too fast
	{
		s16 drag = vx >> 5		// Do not divide here, as it rounds differently for negative numbers
		if (drag != 0)
		{
			vx -= drag
			if (drag > 0)
				vx = max(vx, 0)
			else
				vx = min(vx, 0)
		}
	}

	char.velocity.x = vx
}

//Don't drain rings
//# address-hook(0x011b26) end(0x011bdc)
function void Character.UpdateRingsInSuperForm()
{
	if objA0.update_address != addressof(Character.BaseUpdate.MISCPartner)
	{
		base.Character.UpdateRingsInSuperForm()
		return
	}
}

//Jump moves for player 2
function void Character.updateJumpMoves()
{
	if objA0.update_address != addressof(Character.BaseUpdate.MISCPartner)
	{
		base.Character.updateJumpMoves()
		return
	}

	u8 input_state     = control.tails.state
	u8 input_pressed   = control.tails.pressed
	bool isSuperActive = false

	if (char.jumping)
	{
		// Limit velocity.y
		s16 max_vy = (char.flags & char.flag.UNDERWATER) ? -0x200 : -0x400
		if (char.velocity.y < max_vy)
		{
			// Limit vertical velocity while not pressing any jump button
			//  -> This is important to support low jumps by just tapping the button briefly
			if ((input_state & CONTROL_ABC) == 0)
			{
				char.velocity.y = max_vy
			}
		}
		else
		{
			if (char.double_jump_state == 0)
			{

				// Check if pressed jump again in mid-air
				if (input_pressed & CONTROL_ABC)
				{
				#if STANDALONE
					// Check for other things to do instead of the usual reaction to jump button pressed
					if (onCharacterPressedJumpInMidAir(input_state, input_pressed))
				#endif
					{
						if (char.character == CHARACTER_SONIC)
						{
							SonicPressedJumpInMidAir()
						}
						else if (char.character == CHARACTER_TAILS)
						{
							TailsPressedJumpInMidAir()
						}
						else if (!competition_mode.active)
						{
							KnucklesPressedJumpInMidAir()
						}
						else
						{
							// Knuckles behaves just like Sonic in competition mode
							SonicPressedJumpInMidAir()
						}
					}
				}
			}

		#if STANDALONE
			if (Game.getSetting(SETTING_DROPDASH) && char.character == CHARACTER_SONIC && !competition_mode.active)
			{
				// Handle drop dash
				//  -> Can only be charged if there is no shield active (only exception: drop dash charge started already, when shield gets active -- this reflects Sonic Mania's behavior)
				//  -> But can be charged if invincible (incl. Super / Hyper Sonic)
				bool chargeDropDash = (control.player1.state & CONTROL_ABC) && ((char.bonus_effect & char.bonus.ELEMENTAL_SHIELDS) == 0 || (char.bonus_effect & char.bonus.INVINCIBLE) || sonic.dropdash_counter > 0) && char.double_jump_state
				if (chargeDropDash)
				{
					if (sonic.dropdash_counter < DROPDASH_FULLCHARGE)
					{
						// Drop dash charging
						++sonic.dropdash_counter
						if (sonic.dropdash_counter == DROPDASH_FULLCHARGE)
						{
							// Fully charged now
							char.state = char.state.SONIC_DROPDASH
							Audio.playAudio("dropdash_charge", AudioContext.CONTEXT_SOUND)
						}
					}
					Input.setControllerRumbleByAddress(A0, 0.0f, 0.25f, 100)
				}
				else if (sonic.dropdash_counter > 0)
				{
					// Abort drop dash
					sonic.dropdash_counter = 0
					char.state = char.state.ROLLING
				}
			}
		#endif
		}
	}
	else
	{
		if (char.spindash == 0)
		{
			char.velocity.y = max(char.velocity.y, -0x0fc0)
		}
	}
}

//Player 2's spindash
//# translated(0x011bde) end(0x011cf0)
//# translated(0x011d16) end(0x011da4)
//# translated(0x0151fc) end(0x01530c)
//# translated(0x015332) end(0x0153c0)
function bool Character.UpdateSpindash()
{
	if objA0.update_address != addressof(Character.BaseUpdate.MISCPartner)
	{
		return base.Character.UpdateSpindash()
	}

#if STANDALONE
	// Ignore this while charging the Super Peel-Out
	if (char.spindash == 0x80)
		return false
#endif

	u8 input_state   = control.tails.state
	u8 input_pressed = control.tails.pressed

	if (char.spindash == 0)
	{
		bool canStartSpindash = (char.state == char.state.COWERING) && (input_pressed & CONTROL_ABC)
		if (!canStartSpindash)
		{
			// Nothing to see here
			return false
		}

		// Start spindash
		char.state = char.state.SPINDASH
		playSound(SFX_SPINDASH_CHARGE)

		char.spindash = 1
		char.spindash_charge = 0
		if (char.drown_countdown >= 12)
		{
			// Set state of dust cloud object to 0x02
			u8[A6 + 0x20] = 0x02
		}
	}
	else
	{
		if (input_state & CONTROL_DOWN)
		{
			// Update spindash
			if (char.spindash_charge > 0)
			{
				char.spindash_charge -= char.spindash_charge >> 5
				if (s16(char.spindash_charge) < 0)
					char.spindash_charge = 0
			}

			if (input_pressed & CONTROL_ABC)
			{
				// Charge up
				char.state.both = 0x0900		// char.state.SPINDASH, char.state.RUNNING
				char.spindash_charge = min(char.spindash_charge + 0x200, 0x800)
				playSound(SFX_SPINDASH_CHARGE)
			}
		#if STANDALONE
			Input.setControllerRumbleByAddress(A0, 0.0f, 0.2f, 100)
		#endif
		}
		else
		{
			releaseSpindash()
		}

		// Center camera y-offset again
		centerCameraYOffset()
	}

	Character.CheckAgainstMoveBorders()
	Character.UpdateRotationOnGround()
	partialUpdateCharacterOnGround()

	return true
}

//Player 2's ground controls
function void updateCharacterControlOnGround()
{
	if objA0.update_address != addressof(Character.BaseUpdate.MISCPartner)
	{
		base.updateCharacterControlOnGround()
		return
	}

	u8 input_state     = control.tails.state
	bool isSuperActive = false

	D6.u16 = u16[A4] << 1
	D5.u16 = u16[A4 + 2] >> 1
	if (isSuperActive)
	{
		D5.u16 = 6
	}

	if ((char.spindash & 0x80) == 0 && (char.bonus_effect & char.bonus.INFINITE_INERTIA) == 0)
	{
		if (char.hlock_countdown == 0)
		{
			u16 acceleration = 0x20

			if (input_state & CONTROL_LEFT)
			{
				if (char.groundspeed > 0)
				{
					char.groundspeed -= acceleration
					if (char.groundspeed < 0)
						char.groundspeed = -0x80
				}
				else
				{
					char.flags |= char.flag.FACING_LEFT
					char.state = char.state.ROLLING
				}
			}

			if (input_state & CONTROL_RIGHT)
			{
				if (char.groundspeed < 0)
				{
					char.groundspeed += acceleration
					if (char.groundspeed >= 0)
						char.groundspeed = 0x80
				}
				else
				{
					char.flags &= ~char.flag.FACING_LEFT
					char.state = char.state.ROLLING
				}
			}
		}

		if (char.groundspeed != 0)
		{
			if (char.groundspeed > 0)
				char.groundspeed = max(char.groundspeed - D5.s16, 0)
			else
				char.groundspeed = min(char.groundspeed + D5.s16, 0)
		}

		if (abs(char.groundspeed) < 0x80)
		{
			if (char.spindash == 0)
			{
				// Stop rolling
				char.flags &= ~char.flag.ROLLING

				s16 dy = s16(char.hitbox_extends.y) - s16(char.hitbox.default.y)
				char.position.y.u16 += (global.inv_gravity) ? -dy : dy

				char.hitbox_extends.x = char.hitbox.default.x
				char.hitbox_extends.y = char.hitbox.default.y
				char.state = char.state.STANDING
			}
			else
			{
				char.groundspeed = (char.flags & char.flag.FACING_LEFT) ? -0x400 : 0x400
			}
		}
	}

	centerCameraYOffset()

	char.velocity.x = (s32(lookupCos(char.rotation)) * char.groundspeed) >> 8
	char.velocity.y = (s32(lookupSin(char.rotation)) * char.groundspeed) >> 8

	char.velocity.x = clamp(char.velocity.x, -0x1000, 0x1000)

	Character.UpdateControlOnGroundShared()
}

//Player 2's ground inner updates
function void Character.updateUprightOnGroundInner()
{
	if objA0.update_address != addressof(Character.BaseUpdate.MISCPartner)
	{
		base.Character.updateUprightOnGroundInner()
		return
	}

	u8 input_state     = control.tails.state
	bool isSuperActive = false
	
	//Log = control.tails.state

	// These are in order:
	//  - maximum speed
	//  - maximum acceleration
	//  - maximum deceleration
	D6.u16 = u16[A4]
	D5.u16 = u16[A4 + 2]
	D4.u16 = u16[A4 + 4]

	if ((char.bonus_effect & char.bonus.INFINITE_INERTIA) == 0)
	{
		// Camera move state:
		//   0 = no input up/down
		//   1 = up/down pressed, but still in delay
		//   2 = up/down pressed, actual movement (limit may be reached)
		u8 cameraMoveState = 0

		if (char.hlock_countdown == 0)
		{
			// Movement left or right
			if (input_state & CONTROL_LEFT)
			{
				// Though the original code uses different functions for the three characters here, they actually are identical
				PressedLeftWhileUprightOnGround()
			}
			if (input_state & CONTROL_RIGHT)
			{
				// Though the original code uses different functions for the three characters here, they actually are identical
				PressedRightWhileUprightOnGround()
			}

			// Standing upright?
			D0.u8 = (char.rotation + 0x20) & 0xc0
			if (D0.u8 == 0 && char.groundspeed == 0)
			{
				char.flags &= ~char.flag.PUSHING
				char.state = char.state.STANDING

				checkForBalancing()

				// Can only look up/down when state was not changed to balancing
				if (char.state == char.state.STANDING)
				{
					if (input_state & (CONTROL_UP | CONTROL_DOWN))
					{
						cameraMoveState = 1
						char.state = (input_state & CONTROL_DOWN) ? char.state.COWERING : char.state.LOOKING_UP

						// Start camera movement after countdown
						++char.look_up_down_timer
						if (char.look_up_down_timer >= Character.look_up_down_delay)
						{
							cameraMoveState = 2
							char.look_up_down_timer = Character.look_up_down_delay

							if (char.state == char.state.COWERING)
							{
								// Move camera down (or up in inverse gravity)
								if (global.inv_gravity == 0)
								{
									if (u16[A5] != 0x08)
										u16[A5] -= 2
								}
								else
								{
									if (u16[A5] != 0xd8)
										u16[A5] += 2
								}
							}
							else
							{
								// Move camera up (or down in inverse gravity)
								if (global.inv_gravity == 0)
								{
									if (u16[A5] != 0xc8)
										u16[A5] += 2
								}
								else
								{
									if (u16[A5] != 0x18)
										u16[A5] -= 2
								}
							}
						}
					}
				}
			}
		}

		if (cameraMoveState < 2)
		{
			if (cameraMoveState < 1)
			{
				char.look_up_down_timer = 0
			}

			centerCameraYOffset()
		}

		// Decelerate
		if (isSuperActive)
		{
			D5.u16 = 0x0c
		}

		if ((input_state & (CONTROL_LEFT | CONTROL_RIGHT)) == 0)	// No left or right pressed
		{
			if (char.groundspeed != 0)
			{
				if (char.groundspeed > 0)
					char.groundspeed = max(char.groundspeed - D5.s16, 0)
				else
					char.groundspeed = min(char.groundspeed + D5.s16, 0)
			}
		}
	}

	char.velocity.x = (s32(lookupCos(char.rotation)) * char.groundspeed) >> 8
	char.velocity.y = (s32(lookupSin(char.rotation)) * char.groundspeed) >> 8

	Character.UpdateControlOnGroundShared()
}

//Player 2's rolling checks
//# address-hook(0x01174a) end(0x0117d8)
//# address-hook(0x014f74) end(0x015000)
function void Character.CheckForStartRolling()
{
	if objA0.update_address != addressof(Character.BaseUpdate.MISCPartner)
	{
		base.Character.CheckForStartRolling()
		return
	}

	u8 input_state = control.tails.state

	if ((char.bonus_effect & char.bonus.INFINITE_INERTIA) == 0)
	{
		if ((input_state & (CONTROL_LEFT | CONTROL_RIGHT)) == 0)	// No left or right pressed
		{
			if (input_state & CONTROL_DOWN)
			{
				if (abs(char.groundspeed) >= 0x100)
				{
					// Start rolling
					if ((char.flags & char.flag.ROLLING) == 0)
					{
						char.flags |= char.flag.ROLLING
						char.hitbox_extends.x = char.hitbox.x.ROLLING
						char.hitbox_extends.y = char.hitbox.y.ROLLING
						char.state = char.state.ROLLING

						s8 dy = (char.character == CHARACTER_TAILS) ? 1 : 5
						char.position.y.u16 += (global.inv_gravity) ? -dy : dy

						playSound(SFX_ROLL)
						if (char.groundspeed == 0)
							char.groundspeed = 0x200
					}
				}
				else if ((char.flags & char.flag.ON_OBJECT) == 0)
				{
					char.state = char.state.COWERING
				#if STANDALONE
					// Also slow down a little
					if (char.groundspeed <= -4)
						char.groundspeed += 4
					else if (char.groundspeed >= 4)
						char.groundspeed -= 4
				#endif
				}
			}
			else
			{
				// Stop crouching
				if (char.state == char.state.COWERING)
					char.state = char.state.RUNNING

			#if STANDALONE
				// Allow for starting the Super Peel-Out even if still moving slowly, just like handling for the spindash
				//  (this logic here is active even if the Peel-Out is not enabled)
				if ((input_state & CONTROL_UP) && abs(char.groundspeed) < 0x100 && (char.flags & char.flag.ON_OBJECT) == 0)
				{
					char.state = char.state.LOOKING_UP
					if (char.groundspeed <= -4)
						char.groundspeed += 4
					else if (char.groundspeed >= 4)
						char.groundspeed -= 4
				}
			#endif
			}
		}
	}
}

//Don't kill restart on player 2 dying
//# address-hook(0x0123c2) end(0x01257a)
function void Character.CheckDiedStateEnd()
{
	if (objA0.update_address == addressof(Character.BaseUpdate.MISCPartner)) && objA0.position.y.u16 > camera.position.y.u16 + getScreenHeight()/2
	{
		// Second player Tails
		char.base_state = base_state.NORMAL
		RespawnTails()
	}
	else
		base.Character.CheckDiedStateEnd()
}

//player 2's underwater checks
function void Character.checkForWaterSurface()
{
	if objA0.update_address != addressof(Character.BaseUpdate.MISCPartner)
	{
		base.Character.checkForWaterSurface()
		return
	}

	if (!level.water_present)
		return

	bool wasUnderwaterBefore = (char.flags & char.flag.UNDERWATER) != 0
	bool isUnderwaterNow = (s16(char.position.y.u16) > s16(water.height.current))
	if (isUnderwaterNow == wasUnderwaterBefore)
		return

	++water.transition_counter
	A1 = A0
	UpdateMusicOnWaterTransition()

	bool isSuperActive = super.active
	bool controlFlag = (char.control_flags == 0)
	if (char.character == CHARACTER_TAILS)
	{
		isSuperActive = super.active.tails
		controlFlag = (tails.ai_routine == 4) || (char.control_flags == 0)
	}

	if (isUnderwaterNow)
	{
		char.flags |= char.flag.UNDERWATER

		// Spawn underwater update object
		u32[0xffffcb76] = addressof(UnderwaterUpdate.BaseUpdate)
		u8[0xffffcb76 + 0x2c] = 0x81
		u32[0xffffcb76 + 0x40] = A0
		

		if (controlFlag)
		{
			char.velocity.x >>= 1
			char.velocity.y >>= 2
			if (char.velocity.y != 0)
			{
				// Set state of dust cloud object to 0x01
				u16[A6 + 0x20] = 0x0100
				playSound(SFX_WATERSPLASH)
			}
		}

	#if STANDALONE
		// Update achievement
		if (A0 == 0xffffb000)
		{
			Game.setAchievementValue(ACHIEVEMENT_LBZ_STAY_DRY, 0)
		}
	#endif
	}
	else
	{
		char.flags &= ~char.flag.UNDERWATER

		if (controlFlag && char.base_state != base_state.HURT)
		{
			if (char.velocity.y >= -0x400)
			{
				char.velocity.y *= 2
			}
		}

		if (char.state != char.state.DISAPPEARED && char.velocity.y != 0)
		{
			// Set state of dust cloud object to 0x01
			u16[A6 + 0x20] = 0x0100
			char.velocity.y = max(char.velocity.y, -0x1000)
			playSound(SFX_WATERSPLASH)
		}
	}

	// Update physics
	setSpeedCapProperties(A4)
}

//Load player 2's palette
function void copyPaletteDataFromTable(u8 index, u16 ramAddress)
{
	base.copyPaletteDataFromTable(index, ramAddress)
	
	if global.characters != CHARACTER_REIMU || !(global.zone >= 0x0a && global.zone <= 0x0c)
		return
	
	u32 dest += ramAddress - 0xfc00				// With this, dest can be changed to non-faded palette and/or secondary palette
	if (EXTENDED_CHARACTER_PALETTES)
	{
		u8 paletteVariant = 0xff
		if (index == 0x03 || index == 0x05)
		{
			paletteVariant = 0
		}
		else if (index == 0x2b || index == 0x2c)
		{
			paletteVariant = 1		// AIZ underwater
		}
		else if (index == 0x39)
		{
			paletteVariant = 2		// ICZ underwater
		}
		else if (index == 0x31 || index == 0x32)
		{
			paletteVariant = 3		// HCZ underwater
		}
		else if (index == 0x2d  || index == 0x2e || index == 0x3a)
		{
			paletteVariant = 4		// CNZ/LBZ underwater
		}

		if (paletteVariant != 0xff)
		{
			u32 A0backup = A0
			//If for whatever reason you need to load a base character's palette, just check for this, and return base in getCharacterPaletteKey()
			A0 = 0x69696968
		
			u8 char = MISC.player2.character
			u8 offset = isMainCharacter(CHARACTER_TAILS) ? 0x20 : 0
			
			if (paletteVariant == 0)
			{
				// Load all characters' normal (non-underwater) palettes, either to fading or non-fading palette buffer
				dest = (ramAddress == 0xfc00) ? 0x802000 : 0x802180
				loadCharacterPalette(char,    dest + 0x40 - offset, 0)
			}
			else
			{
				// Load all characters' underwater palettes, either to fading or non-fading palette buffer
				dest = (ramAddress == 0xf080) ? 0x802300 : 0x802480
				loadCharacterPalette(char,    dest + 0x40 - offset, paletteVariant)
			}
			
			A0 = A0backup
		}
	}
}

function void fn0218ce()
{
	if objA1.update_address != addressof(Character.BaseUpdate.MISCPartner)
		base.fn0218ce()
		
	DrawObject()
}

//fix debug mode
function bool updateDebugModeInput(bool playingAsTails)
{
	if objA0.update_address != addressof(Character.BaseUpdate.MISCPartner)
		return base.updateDebugModeInput(playingAsTails)
	return false
}

//# address-hook(0x092ad4) end(0x092c52)
function void DebugMode.EvaluateInput()
{
	if objA0.update_address != addressof(Character.BaseUpdate.MISCPartner)
		base.DebugMode.EvaluateInput()
}

//Correct bluespheres colours
function void copyMemory(u32 destAddress, u32 sourceAddress, u32 bytes)
{
	base.copyMemory(destAddress, sourceAddress, bytes)
	if sourceAddress == 0x00896e && global.characters == CHARACTER_REIMU && MISC.getCharBase(MISC.player2.character) == CHARACTER_SONIC
	{
		base.copyMemory(0xfffffc90, 0x0089ee, 0x10)
	}
}

//fix ssz bar
//# address-hook(0x0453e6) end(0x045526)
function void fn0453e6()
{
    if (objA1.update_address != addressof(Character.BaseUpdate.MISCPartner)) || (u8[A1 + 0x38] == CHARACTER_TAILS)
    {
        base.fn0453e6()
        return
    }
    if (D1 == 0x11)
        D1 = 0x14
    base.fn0453e6()
}

/*
	MGZ 2 boss replacement
	just replaces it with Knuckles' boss. you can change this if you wish, but we can't guarantee it'll work.
*/

//# address-hook(0x06c31a) end(0x06c32c)
function void fn06c31a()
{
	if (MISC.player2.character == CHARACTER_TAILS) || MISC.player2.character == 0
	{
		base.fn06c31a()
		return
	}
	objA0.update_address = 0x06c698
}

//# address-hook(0x051842) end(0x0518f4)
function void InitLevelScrolling.MGZ2()
{
	base.InitLevelScrolling.MGZ2()
	if (MISC.player2.character != CHARACTER_TAILS && MISC.player2.character != 0)
		MISCPartner.setupMGZArena()
}

//# address-hook(0x0511c8) end(0x051278)
function void fn0511c8()
{
	base.fn0511c8()
	if (MISC.player2.character != CHARACTER_TAILS && MISC.player2.character != 0 && global.zone_act == 0x0201) // act 2 gets loaded
		MISCPartner.setupMGZArena()
}

function void MISCPartner.setupMGZArena()
{
	u8[0xffff87fe] = 0x0d
	u8[0xffff877f] = 0x81
	u8[0xffff87ff] = 0x83
	u8[0xffff8780] = 0x45
	u8[0xffff8800] = 0x4a
	u8[0xffff8781] = 0x45
	u8[0xffff8801] = 0x4a
	u8[0xffff8782] = 0x45
	u8[0xffff8802] = 0x4a
	u8[0xffff8783] = 0x45
	u8[0xffff8803] = 0x4a
	u8[0xffff8784] = 0x7b
	u8[0xffff8804] = 0xb2
	u8[0xffff8806] = 0xc6
	u8[0xffff8807] = 0x01
}

//# address-hook(0x06c698) end(0x06c6ee)
function void fn06c698()
{
	if (MISC.player2.character == CHARACTER_TAILS) || MISC.player2.character == 0
	{
		base.fn06c698()
		return
	}
	// Use main boss music
	objA0.value26 = MUSIC_MAINBOSS
	StartBossFight()

	objA0.update_address = 0x06c6f4
	objA0.countdown_callback = 0x06c6fa

	Kosinski.addToDMAQueue(0x36b340, 0x67e0)		// Boss sprites

	Kosinski.addToDMAQueue(0x36d572, 0x8bc0)		// Falling debris sprites

	requestLoadingPatterns(0x6d)		// Robotnik's ship, boss explosions, and capsule sprites
	loadPaletteLine1(0x06d97c)

	level.bossarea.left -= getScreenExtend()
	level.bossarea.right += getScreenExtend()
}

//# address-hook(0x06c6f4) end(0x06c6f4)
function void fn06c6f4()
{
	base.fn06c6f4()
	if (MISC.player2.character == CHARACTER_TAILS) || MISC.player2.character == 0
		return
	if (objA0.countdown_value < 0)
		objA0.update_address = objA0.countdown_callback
}

//# address-hook(0x06c8b4) end(0x06c8ee)
function void fn06c8b4()
{
	if (MISC.player2.character == CHARACTER_TAILS) || MISC.player2.character == 0
	{
		base.fn06c8b4()
		return
	}
	objA0.update_address = 0x06c8f4
	level.wait_for_results = 0xff
	level.boss_encounter = 0

	if (allocDynamicObjectStd())
	{
		// Spawn capsule
		objA1.update_address = 0x086540
		objA1.position.x.u16 = 0x3ee8
		objA1.position.y.u16 = 0x730
	}

	screenmover_target.right = 0x3e48 + getScreenExtend()

	// "spawnSimpleChildObjects(0x084b00)" replaced by:
	spawnSimpleChildObjects(0x084a48, 1)		// Screen mover for the right border
}

//# address-hook(0x06c862) end(0x06c888)
function void fn06c862()
{
	base.fn06c862()
	if (MISC.player2.character == CHARACTER_TAILS) || MISC.player2.character == 0
		return
	objA0.position.y.u16 = 0x680
}

//# address-hook(0x06d4dc) end(0x06d512)
function void fn06d4dc()
{
	if (MISC.player2.character == CHARACTER_TAILS) || MISC.player2.character == 0
	{
		base.fn06d4dc()
		return
	}
	// Determine movement from the ground up
	GetRandomNumber()
	D0.u16 &= 0x7f
	D1.u16 = (D0.u16 & 0x01) + 4
	D2.u16 = u16[0xfffffa82] >> 1
	objA0.render_flags |= render_flag.FLIP_X
	D3.u8 = u8[0x06d516 + D2.u16]
	if (D3.u8 != 0)
	{
		D0.s16 = -D0.s16
		objA0.render_flags &= ~render_flag.FLIP_X
	}
	D1.u8 += D3.u8
	D3.u16 = 0x752

	// D0.s16 is a positional offset here, between -0x80 and 0x7f
	// D1.u16 determines how he moves:
	//  - 0x04 = Going straight up, looking right
	//  - 0x05 = Going diagonally from lower right to upper left, looking right
	//  - 0x06 = Going straight up, looking left
	//  - 0x07 = Going diagonally from lower left to upper right, looking left

	A2 = 0xfffffa8a
	fn06d45e()
}